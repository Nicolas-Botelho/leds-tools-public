{"searchDocs":[{"title":"Instalation","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/installation","content":"Instalation To install Andes, follow these steps: Open Visual Studio CodeClick on ExtensionsSearch for Andes LEDSClick to install the ANDES extension by LEDS IFES","keywords":"","version":"Next"},{"title":"How to Use","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/howtouse","content":"How to Use Create a file with extension .andes (e.g., slave_one.spark)Define the class diagramSave the file .andesClick with right botton and chose one optionAfter that, Andes will generate the software artifacts","keywords":"","version":"Next"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/faq","content":"Frequently Asked Questions to do !","keywords":"","version":"Next"},{"title":"Metamodel","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/metamodel","content":"","keywords":"","version":"Next"},{"title":"Model​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#model","content":" Description: The Model serves as the entry point of the grammar. It encapsulates the overall project structure by containing multiple Project, Requirements, and UseCase instances.Attributes: projects: A collection of Project instances associated with the model.requirements: A collection of Requirements instances defining the system's requirements.useCases: A collection of UseCase instances representing the system's use cases. Relationships: Contains: Multiple Project instances.Multiple Requirements instances.Multiple UseCase instances.  ","version":"Next","tagName":"h2"},{"title":"Project​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#project","content":" Description: Represents a project within the model, providing an overview and specific details about the project's purpose and scope.Attributes: id: A unique identifier for the project.name: The name of the project.description: A detailed description of the project.purpose: The primary purpose of the project.miniworld: A string describing the project's mini-world or domain context. Relationships: Contained By: Belongs to one Model.  ","version":"Next","tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#requirements","content":" Description: Encapsulates the system's requirements, categorizing them into functional and non-functional types.Attributes: id: A unique identifier for the requirements section.name: The name of the requirements section.description: A description outlining the scope of the requirements.requirements: A collection of Requirement instances detailing individual requirements. Relationships: Contains: Multiple Requirement instances.  ","version":"Next","tagName":"h2"},{"title":"Requirement (Abstract Class)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#requirement-abstract-class","content":" Description: An abstract representation of a system requirement. Serves as a base for more specific requirement types.Attributes: name: The name of the requirement.description: A detailed description of the requirement. Inheritance: FunctionalRequirement and NonFunctionalRequirement inherit from Requirement.  ","version":"Next","tagName":"h2"},{"title":"FunctionalRequirement​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#functionalrequirement","content":" Description: Represents a functional requirement detailing specific behaviors or functions the system must perform.Inheritance: Inherits from Requirement.  ","version":"Next","tagName":"h2"},{"title":"NonFunctionalRequirement​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#nonfunctionalrequirement","content":" Description: Represents a non-functional requirement specifying system attributes such as performance, security, or usability.Inheritance: Inherits from Requirement.  ","version":"Next","tagName":"h2"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#usecase","content":" Description: Represents a use case within the system, defining a specific functionality or behavior that actors can perform.Attributes: name: A QualifiedName that uniquely identifies the use case.fullName: A string representing the full name of the use case.kind: An enumeration (Kind) indicating the type of use case (manage or view).performedActors: A collection of Actor instances that perform this use case.involvedEntities: A collection of Entity instances involved in this use case.extendsUseCases: A collection of UseCase instances that this use case extends.includesUseCases: A collection of UseCase instances that this use case includes. Relationships: Performed By: Multiple Actor instances. Involves: Multiple Entity instances. Extends: Can extend multiple UseCase instances. Includes: Can include multiple UseCase instances.  ","version":"Next","tagName":"h2"},{"title":"Actor​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#actor","content":" Description: Represents an actor within the system, typically a user or external system that interacts with use cases.Attributes: name: A QualifiedName that uniquely identifies the actor.entity: An Entity that the actor is associated with.superType: An optional reference to another Actor that this actor extends. Relationships: Extends: An Actor can optionally extend another Actor, establishing an inheritance relationship.Implements: Implements the Entity interface. ","version":"Next","tagName":"h2"},{"title":"Andes Lib - Documentation","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/andes-lib_DOCUMENTATION","content":"","keywords":"","version":"Next"},{"title":"IRender Interface​","type":1,"pageTitle":"Andes Lib - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-lib_DOCUMENTATION#irender-interface","content":" export default interface IRender { public render(identationStartLevel: number = 0): string; }   ","version":"Next","tagName":"h2"},{"title":"TODO​","type":1,"pageTitle":"Andes Lib - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-lib_DOCUMENTATION#todo","content":" documentar cada um dos renders ","version":"Next","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/AndesOverview","content":"Overview Andes (Analysis as Code) is a tool that helps Software Requirements Engineers model requirements, use cases, and actors, including their interrelations. From these models, Andes automatically generates: Markdown documentation with requirements, use cases, and actors;End-to-end test cases in Gherkin language;Documents for Made, assisting in project management;Documents for Spark, supporting software development. With Andes, you transform requirements models into ready-to-use documentation and tests, saving time and reducing errors.","keywords":"","version":"Next"},{"title":"Understanding the Language","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/lang","content":"","keywords":"","version":"Next"},{"title":"Project Structure​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#project-structure","content":" This constructor allows you to define essential details about the project, including the project's name, a description summarizing its goals and features, its purpose, and a miniworld that provides context for the project.  overview Name // Replace &quot;Name&quot; for what you want to be de ID overview { name: &quot;Cool Project&quot; // project's name description: &quot;That's a cool project&quot; // description about the project purpose: &quot;This project can make the people be cool&quot; // the purpose of this project. miniworld: &quot;You can write as much as you want&quot; // The Context about the project }   ","version":"Next","tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#requirements","content":" Requirements outline the essential aspects of a system, including its name and a brief description of its objectives. They specify functional and non-functional needs, detailing what the system should accomplish, its performance characteristics, and business rules to ensure compliance with policies.  requirements RequirementsID // Replace &quot;RequirementsID&quot; for what you want to be de ID requirements { name: &quot;module requirements&quot; // module's name description: &quot;module requirements&quot; // description about the module // Here are the functional, non-functional requirements and business rules }   Inside the requirements Model   functional_requirement FR01 { description: &quot;This system should be able to manage clients&quot; priority: &quot;High&quot; depend: RequirementsID.FR03 } non_functional_requirement NFR01 { description: &quot;The system must ensure that, in each action confirmation, the potential impacts of the action are presented in a clear and understandable way to the user&quot; priority: &quot;Medium&quot; depend: RequirementsID.FR01 } bussines_rule BR01 { description: &quot;This system should be link with paypal&quot; priority: &quot;Low&quot; depend: RequirementsID.NFR01 }   In this structure, the system can accommodate multiple functional and non-functional requirements, as well as business rules within the same module. To add additional requirements, simply change the identifier (e.g., FR01, NFR01, BR01) accordingly.  ","version":"Next","tagName":"h2"},{"title":"Actors​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#actors","content":" Actors represent the individuals or entities that interact with the system. Each actor is identified by a unique identifier and includes a name that designates their role. Additionally, an optional description can provide further details about the actor's function or responsibilities within the system, clarifying how they engage with the various components and processes.  actor ActorID // Replace &quot;ActorID&quot; with the identifier for the actor { name: &quot;Roberto&quot; // Name of the actor description: &quot;Description of the actor's role or function&quot; // Optional: detailed description of the actor }   ","version":"Next","tagName":"h2"},{"title":"Use Case​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#use-case","content":" The use case structure defines the interactions between actors and the system to achieve specific goals. It includes essential details such as the use case's identifier, name, description, dependencies, and the actor involved.  usecase UC01 // Replace &quot;UC01&quot; with the identifier for the use case { name: &quot;Use Case Name&quot; // Name of the use case description: &quot;Description of the use case&quot; // Detailed description of the use case depend: UC01, UC02 // Optional: list of dependent use cases performer: ActorID // The actor(s) involved in the use case requirements: RequirementsID.RF01 // The requirement(s) involved in the use case // Here are the Events }   Events are defined within the use case to represent specific actions or occurrences that take place. Each event includes its identifier, name, description, dependencies, and an action description if applicable.  event EventID // Replace &quot;EventID&quot; with the identifier for the event { name: &quot;Event Name&quot; // Name of the event description: &quot;Description of the event&quot; // Detailed description of the event depend: UC01.EventID // Optional: identifier of the dependent use case and event requirements: RequirementsID.RF01 // Optional: The requirement(s) involved in the event action: &quot;Action description&quot; // Optional: description of the action performed during the event }  ","version":"Next","tagName":"h2"},{"title":"Difference between Andes Lib and Andes GPS Project","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/DIFF_LIB_TOOL","content":"","keywords":"","version":"Next"},{"title":"📚 Andes Lib​","type":1,"pageTitle":"Difference between Andes Lib and Andes GPS Project","url":"/leds-tools-public/andes/new_documentation/DIFF_LIB_TOOL#-andes-lib","content":" Acts as an auxiliary compiler.Defines interfaces, base classes, and fundamental types that represent entities in the Andes model.Serves as an abstraction layer for: Use casesRequirementsEntitiesRelationshipsEvents    ","version":"Next","tagName":"h2"},{"title":"Andes​","type":1,"pageTitle":"Difference between Andes Lib and Andes GPS Project","url":"/leds-tools-public/andes/new_documentation/DIFF_LIB_TOOL#andes","content":" Is the main tool.Responsible for: Defining the Andes grammar (.langium)Parsing models written in the Andes DSLTranslating the grammar elements into Andes Lib types (via translatorutils) ","version":"Next","tagName":"h2"},{"title":"Andes - Documentation","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION","content":"","keywords":"","version":"Next"},{"title":"Grammar Structure​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#grammar-structure","content":" The Andes grammar is defined in .langium files. It describes the tokens and rules that make up the model.    ","version":"Next","tagName":"h2"},{"title":"andes.langium​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#andeslangium","content":" Defines the high-level elements of the model:  Project: describes general information (name, description, purpose, mini-world, architecture).Module: encapsulates local entities, enums, and submodules.AbstractElement: can be Module or EnumX.    ","version":"Next","tagName":"h3"},{"title":"entities.langium​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#entitieslangium","content":" Defines the structure of entities and their elements:  LocalEntity: entities defined in the project.ImportedEntity: imported entities.Attributes: Attribute: primitive attributes (with constraints like unique, max, min).EnumEntityAtribute: attributes based on enums. Relationships: OneToOne, OneToMany, ManyToOne, ManyToMany. Functions: FunctionEntity: allows defining operations on entities.    ","version":"Next","tagName":"h3"},{"title":"usecase.langium​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#usecaselangium","content":" Defines actors, use cases, and events:  Actor: links an actor to an entity.UseCase: a use case containing requirements, events, and actors.Event: an event with an action, requirements, and dependencies.    ","version":"Next","tagName":"h3"},{"title":"requirements.langium​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#requirementslangium","content":" Defines requirements:  FunctionalRequirementNonFunctionalRequirementBussinesRule  Each requirement can have:  DescriptionPriorityDependencies on other requirements    ","version":"Next","tagName":"h3"},{"title":"Parse and Translation Process​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#parse-and-translation-process","content":" The translation is done in the translatorutils.ts file, which converts the AST (Abstract Syntax Tree of the Andes grammar) into Andes Lib classes.  ","version":"Next","tagName":"h2"},{"title":"Translation Examples:​","type":1,"pageTitle":"Andes - Documentation","url":"/leds-tools-public/andes/new_documentation/andes-gps-projeto_DOCUMENTATION#translation-examples","content":" Entities translateLocalEntity(entity: LocalEntity): EntityTypeConverts grammar entities into EntityType objects. Attributes translateAttribute(attr: Attribute): AttributeType Enums translateEnumx(enumX: EnumX): EnumEntityType Relationships translateRelation(rel: Relation): RelationType Use Cases translateUseCase(useCase: UseCase): UseCaseClassGenerates a UseCaseClass instance with translated requirements and events. Events translateEvent(event: Event, ucRef: UseCaseClass): EventType Requirements translateRequirements(req: Requirements): RequirimentAgregationClasstranslateRequirement(req: FunctionalRequirement | NonFunctionalRequirement | BussinesRule): RequirimentsBaseClass Actors translateActor(actor: Actor): ActorType  Thus, the tool ensures that any model written in the Andes DSL is converted into a structured and typed representation, ready for use in documentation generation or analysis. ","version":"Next","tagName":"h3"},{"title":"How to use Andes","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/howtouse","content":"","keywords":"","version":"Next"},{"title":"ANDES VS Code Extension​","type":1,"pageTitle":"How to use Andes","url":"/leds-tools-public/andes/new_documentation/howtouse#andes-vs-code-extension","content":" Installation via Marketplace​  Open Visual Studio Code.Navigate to the Extensions tab on the left sidebar or press Ctrl+Shift+X.In the search field, type &quot;ANDES&quot;.Find the extension published by ledsifes and click the Install button.    Writing ANDES Code​  After installation, the extension will be activated automatically whenever you open or create a file with the .andes extension. Create a new file (e.g., myproject.andes) and begin describing your requirements and use cases according to the language's syntax.    Generating Artifacts (Documents and Tests)​  With an .andes file open in the editor, you can trigger the generation commands by right-clicking inside the text editor. The ANDES generation options will appear in the menu (in some cases, you may need to restart VS Code).  The available commands are:  Generate AllGenerate Management Documentation to MADEGenerate Project DocumentationGenerate Spark DocumentGenerate Test Documentation with OpenAI  Once you select an option, the corresponding files will be generated in your project.    ","version":"Next","tagName":"h3"},{"title":"Command-Line Interface (CLI)​","type":1,"pageTitle":"How to use Andes","url":"/leds-tools-public/andes/new_documentation/howtouse#command-line-interface-cli","content":" Development Environment Setup​  Clone the Repository: Get the project's source code from GitHub by running git clone https://github.com/leds-org/leds-tools-andes.git and then change to the project directory with cd leds-tools-andes.Install Dependencies: The project is Node.js-based. Use npm install to install all dependencies.Compile the Project: The TypeScript source code needs to be compiled to JavaScript using npm run build.    Syntax and Usage Examples​  Basic Syntax: Use node bin/cli.js generate &lt;source_file.andes&gt;.Options: Use -d, --destination &lt;dir&gt; to specify the destination directory for the generated files. If omitted, a generated directory is created by default.Example: To generate artifacts from the requisitos.andes file and save them to a folder named documentacao, run node bin/cli.js generate/requisitos.andes -d./documentacao. The tool will process and validate the file, and if there are no errors, it will create the artifacts in the specified destination ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/overview","content":"","keywords":"","version":"Next"},{"title":"Features:​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/andes/overview#features","content":" Create a Markdon Documentation with Software Requirements, User Case and Actores.End-to-End Test Case using Gherkin grammar.Made`s document to support management process.Spark`s document to support Development process. ","version":"Next","tagName":"h2"},{"title":"Andes Lib Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/lib_architecture","content":"","keywords":"","version":"Next"},{"title":"Overview of the Modules​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#overview-of-the-modules","content":" src/ ├── application/ # High-level applications (builders, creators, parsers) ├── documentation/ # Integration with Docusaurus ├── graph/ # Graph manipulation ├── model/ # Model and type definitions ├── renders/ # Rendering in different formats     ","version":"Next","tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#modules","content":" ","version":"Next","tagName":"h2"},{"title":"1. application/​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#1-application","content":" Contains the application logic that orchestrates the models and generates artifacts.  domain/ → Main domain construction (e.g., BuildDomain.ts).purpose/ → Purpose and scope of the modules.requirements/ → Requirements parsers (GraphParser, TableParser, RequirementsExtractor).usecase/ → Creation and parsing of use cases.made/ → Creation of applications based on defaults (backlog, epics, stories).Root files → ApplicationCreator.ts, DocusaurusCreator.ts, IO.ts.  ⚡ Role: transform the models (in model/) into usable/documentable applications.    ","version":"Next","tagName":"h3"},{"title":"2. documentation/​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#2-documentation","content":" Integration with Docusaurus, including generation of diagrams and use cases.  docusaurus/ ClassDiagram.ts → Class diagram creation.ModelUseCases.ts → Use case documentation.DocksaurusService.ts → Central integration service.application.ts → Orchestrator.  ⚡ Role: automatic generation of visual and technical documentation.    ","version":"Next","tagName":"h3"},{"title":"3. graph/​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#3-graph","content":" Contains graph.ts, responsible for manipulation of graphs used in parsing, requirements analysis, and model generation.  ⚡ Role: structural support for relationships between entities.    ","version":"Next","tagName":"h3"},{"title":"4. model/​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#4-model","content":" Defines the core structure of the domain.  andes/ → Classes and types for analysis, projects, and requirements.made/ → Classes related to backlog, roadmap, sprint, tasks, and teams.spark/ → Structures for entities, enums, packages, and inheritance.  ⚡ Role: formally represent the elements modeled by the Andes language.    ","version":"Next","tagName":"h3"},{"title":"5. renders/​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#5-renders","content":" Layer responsible for exporting and visualizing the models in different formats.  dsl/ made/ and spark/ → Renders for DSL elements. markdown/ MermaidRender.ts → Generation of Mermaid diagrams (flowchart, state machine).FileRender.ts, MarkdownRender.ts → Markdown file rendering. plantuml/ PlantUmlRender.ts, classDiagram.ts → UML diagram generation. Other renders → TableRender.ts, SectionRender.ts, ParagraphRender.ts, etc.  ⚡ Role: transform models into visual and documentary representations.    ","version":"Next","tagName":"h3"},{"title":"Architectural Flow​","type":1,"pageTitle":"Andes Lib Architecture","url":"/leds-tools-public/andes/new_documentation/lib_architecture#architectural-flow","content":" Modeling → The user defines projects, requirements, use cases, and backlog (in model/).Application → The application/ module processes the models, generates representations, and prepares for documentation.Graph → Provides structural support in the organization and relationships between entities.Documentation → documentation/ generates structured documents and integrates with Docusaurus.Rendering → renders/ exports in Markdown, UML, Mermaid, and other visual formats. ","version":"Next","tagName":"h2"},{"title":"Andes Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/tool_architcture","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Andes Architecture","url":"/leds-tools-public/andes/new_documentation/tool_architcture#overview","content":" The project is divided into three main parts:  CLI (src/cli/) → Command-line interface, responsible for interacting with the user via terminal and executing commands.Extension (src/extension/) → Entry point for the extension (e.g., VSCode).Language (src/language/) → DSL definitions (based on Langium), including grammar, validation, and scope.    ","version":"Next","tagName":"h2"},{"title":"Directory Structure​","type":1,"pageTitle":"Andes Architecture","url":"/leds-tools-public/andes/new_documentation/tool_architcture#directory-structure","content":" ","version":"Next","tagName":"h2"},{"title":"src/cli/​","type":1,"pageTitle":"Andes Architecture","url":"/leds-tools-public/andes/new_documentation/tool_architcture#srccli","content":" Contains the implementation of the CLI and its utilities.  artifacts/ bdd/ BDDService.ts → Main service for executing BDD scenarios.application.ts → Application that integrates BDD with the rest of the CLI.generator.ts → Generation of BDD-related files. generative_ai/ application.ts → Integration with AI tools. graph/ graph.ts → Graph manipulation and generation. made/ application.ts → Service specific to generation/execution of made artifacts. spark/ application.ts → Service specific to generation/execution of spark artifacts. utils/ envLoader.ts → Utility for loading environment variables. vscode_utils/ vscode-utils.ts → Utility functions for integration with VSCode. Main CLI files cli-utils.ts → Common functions for CLI execution.generator-utils.ts → Helper functions for generators.generator.ts → Orchestrator of artifact generation.main.ts → CLI entry point.translate-utils.ts → Translates objects generated by Langium into objects interpretable by the main library.    ","version":"Next","tagName":"h3"},{"title":"src/extension/​","type":1,"pageTitle":"Andes Architecture","url":"/leds-tools-public/andes/new_documentation/tool_architcture#srcextension","content":" Contains the extension (integration with VSCode).  main.ts → Extension entry point, initializes communication between the editor and the language.    ","version":"Next","tagName":"h3"},{"title":"src/language/​","type":1,"pageTitle":"Andes Architecture","url":"/leds-tools-public/andes/new_documentation/tool_architcture#srclanguage","content":" This is the core of the DSL, built with Langium.  Language definition files: andes.langium → Main grammar of the Andes language.entities.langium → Entity definitions.helpers.langium → Auxiliary rules.requirements.langium → Requirement definitions.terminals.langium → Token/terminal definitions.usecases.langium → Use case definitions. Supporting TypeScript files: andes-module.ts → Main module connecting the parts of the language.andes-scope.ts → Scope rules and reference resolution.andes-validator.ts → Semantic validations of the language.main.ts → Language initialization entry point.main-browser.ts → Initialization for browser environments.    ","version":"Next","tagName":"h3"},{"title":"Architectural Flow​","type":1,"pageTitle":"Andes Architecture","url":"/leds-tools-public/andes/new_documentation/tool_architcture#architectural-flow","content":" User runs the CLI Entry at src/cli/main.ts.Invokes modules such as BDD, graph generation, and made/spark files.When it needs to interpret language models, it uses translate-utils.ts. Extension (VSCode) Loaded via src/extension/main.ts.Uses the DSL definition in src/language/ for parsing, validation, and scope.Displays feedback in the editor. Language (Langium) DSL defined in .langium files.Parsing + validation → generates AST.The AST is translated by translate-utils.ts into domain objects understood by the CLI modules.   ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/andes/project_managment#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tCreate Analysis Document\tCreate an analysis document in Markdown with the following information: Requirements, Use Cases, Class Diagram, and State Diagram, to be published on Docusaurus.\t100\tImprove Comunication betwen teams in 10% 2\tDependency Analysis\tUpdate the analysis document with a section for dependencies between use cases and events.\t90\tImprove project management in 15% 3\tModule Planning\tCreate a planning document in the Made format, based on use cases.\t80\tImprove project management in 5% 4\tUpdate Planning with Tasks\tUpdate the planning document with tasks for each event, based on the development process.\t82\tImprove project management in 10% 5\tCreate Development Artifacts\tCreate a Spark-type document, using the data from the analysis.\t70\tImprove developing process int in 10%  ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/andes/project_managment#general-planning","content":" Release 1.0 - (14/10/2024 - 01/11/2024): create a documentation using Software Requirement information.Release 2.0 - (04/11/2024 - 31/11/2024): create a Made and Spark documents  ","version":"Next","tagName":"h2"},{"title":"Release 1.0 - 01/11/2024​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/andes/project_managment#release-10---01112024","content":" Goal: Create an analysis document in Markdown with the following information: Requirements, Use Cases, Class Diagram, and State Diagram, to be published on Docusaurus and Update the analysis document with a section for dependencies between use cases and events. . Features: ID 1 and ID 2 Deadline I - 25/10/2024 ID 1: Create an analysis document in Markdown with the following information: Requirements, Use Cases, Class Diagram, and State Diagram, to be published on Docusaurus Deadline II - 01/11/2024 ID 2: Update the analysis document with a section for dependencies between use cases and events.  ","version":"Next","tagName":"h2"},{"title":"Use Exemple","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/new_documentation/andes_example","content":"Use Exemple Here you can find a example of the grammar used in the Andes' files. overview Todolist { name: &quot;ToDoList&quot; description: &quot;System for organizing daily tasks&quot; purpose: &quot;Help users manage their tasks in a simple, efficient, and organized way&quot; miniworld: &quot;Users can register tasks, organize by categories, track deadlines and statuses&quot; Architecture: python } requirements Requirements { name: &quot;ToDo Requirements&quot; description: &quot;Requirements for the functioning of the To-Do List system&quot; functional_requirement RF01 { description: &quot;The system must allow users to register with name, email, and password&quot; priority: &quot;High&quot; } functional_requirement RF02 { description: &quot;The system must allow user authentication&quot; priority: &quot;High&quot; depend: Requirements.RF01 } functional_requirement RF03 { description: &quot;The system must allow users to create new tasks&quot; priority: &quot;High&quot; } functional_requirement RF04 { description: &quot;The system must allow users to edit existing tasks&quot; priority: &quot;High&quot; } functional_requirement RF05 { description: &quot;The system must allow users to delete tasks&quot; priority: &quot;High&quot; } functional_requirement RF06 { description: &quot;The system must list the user's tasks&quot; priority: &quot;High&quot; } functional_requirement RF07 { description: &quot;The system must allow changing the status of tasks&quot; priority: &quot;High&quot; } functional_requirement RF08 { description: &quot;The system must allow users to create and manage categories&quot; priority: &quot;Medium&quot; } functional_requirement RF09 { description: &quot;The system must allow filtering tasks by status, date, and category&quot; priority: &quot;Medium&quot; } functional_requirement RF10 { description: &quot;The system may send notifications about pending or upcoming tasks&quot; priority: &quot;Low&quot; } non_functional_requirement RNF01 { description: &quot;The system must have secure authentication with password encryption&quot; priority: &quot;High&quot; } non_functional_requirement RNF02 { description: &quot;It must be a responsive application, working well on desktop and mobile&quot; priority: &quot;High&quot; } non_functional_requirement RNF03 { description: &quot;The backend must be developed in Django&quot; priority: &quot;High&quot; } non_functional_requirement RNF04 { description: &quot;The frontend must be developed in React&quot; priority: &quot;High&quot; } non_functional_requirement RNF05 { description: &quot;The system must support at least 100 simultaneous users&quot; priority: &quot;Medium&quot; } non_functional_requirement RNF06 { description: &quot;Request response time must not exceed 2 seconds in 95% of cases&quot; priority: &quot;High&quot; } } usecase Registration { name: &quot;Registration and Authentication&quot; description: &quot;User registers and logs in&quot; requirements: Requirements.RF01, Requirements.RF02 } usecase TaskManagement { name: &quot;Task Management&quot; description: &quot;User creates, edits, deletes, and changes task statuses&quot; requirements: Requirements.RF03, Requirements.RF04 } usecase TaskOrganization { name: &quot;Task Organization&quot; description: &quot;User organizes tasks by category, date, and status&quot; requirements: Requirements.RF06, Requirements.RF08 } usecase Notifications { name: &quot;Notifications&quot; description: &quot;System sends reminders to the user&quot; requirements: Requirements.RF10 event EventX{ name: &quot;Name&quot; action: &quot;User Does Something&quot;, &quot;System Responds With Something&quot; } } module ToDoApp { description: &quot;Main module of the To-Do List application&quot; enum Priority { low medium high } enum Status { pending in_progress completed canceled } // Description of the User class entity User { name: string _email: email password: string } entity Category { name: string user OneToMany User } entity Task { title: string description: string due_date: date priority uses Priority status uses Status category ManyToOne Category user ManyToOne User } } ","keywords":"","version":"Next"},{"title":"Design of the Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/01-Design-of-the-architecture","content":"Design of the Architecture MVC ARCHITETURE MVC is an architecture where it is divided into 3 parts, model, view and controller Model: Responsible for data and business logic. It represents Pull Request data, code analysis rules and improvement suggestions, as well as the insertion of comments in the source code. View: Responsible for the user interface. This is where the panel is showing statistics, forecasts (delivery times) and where the user can enter or change the details that interest them most in the analysis. Controller: Manages the interaction between the model and the View. This is when the pull request is inspected on github, sending the data to the model and showing the results in the view.","keywords":"","version":"Next"},{"title":"Explanation of each component and layer","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/02-Explanation-of-each-component-and-layer","content":"","keywords":"","version":"Next"},{"title":"Model:​","type":1,"pageTitle":"Explanation of each component and layer","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/02-Explanation-of-each-component-and-layer#model","content":" Code validation rules. Good practicesStyleQualitySecurityPerformanceAdherence to team/project standards Integration with external analysis APIs, such as the Gemini API (Google), which processes and generates suggestions about the code.Representation of Pull Request data: ID of PRAuthorList of modified filesFile contentsImprovement suggestions Integration with agentops, for monitoring models and agents.Statistical calculations on the analyzed codes, analyzing errors, possible bugs, code smell, an analysis of individual and collective activity.  ","version":"Next","tagName":"h2"},{"title":"View:​","type":1,"pageTitle":"Explanation of each component and layer","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/02-Explanation-of-each-component-and-layer#view","content":" Automatic comment when performing Pull Request on GitHubMessage formatted in the Discord channel or other means of communicationResponse to a frontend APIFormat and display improvement suggestions clearlyAdapt content to the delivery mediumDisplay individual data (for each collaborator) and collective data for a project Display of grades, from 0 to 5, taking into account code validation rules Interface for configuring: API keysURLsDatabaseAccess permissions (ex: github)  ","version":"Next","tagName":"h2"},{"title":"Controller:​","type":1,"pageTitle":"Explanation of each component and layer","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/02-Explanation-of-each-component-and-layer#controller","content":" Detects creation/update of Pull Requests (via GitHub Webhook or n8n)Sends changed code for analysis by the modelFormats the results and forwards them to the output channels via view ","version":"Next","tagName":"h2"},{"title":"Bibliographical references on the adopted architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/04-Bibliographical-references-on-the-adopted-architecture","content":"Bibliographical references on the adopted architecture Clean Architecture A CRAFTSMAN'S Guide To Software Structure And Design, Robert C. MartinModel-View-Controller (MVC) Architecture, John DeaconDesign Patterns: Elements of Reusable Object-Oriented Software, Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides","keywords":"","version":"Next"},{"title":"Code Wise","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#overview","content":" Once installed and configured, CodeWise operates silently in the background. It monitors your Git repository for new commits and automatically triggers a set of intelligent agents that review the code changes, offering structured, insightful feedback saved directly into your workspace.  ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#installation","content":" To use this action in your repository, follow the steps below:  Install the extension locally Configure your .env file with the appropriate LLM credentials: (name of your provider)_API_KEY=your-api-key (ex. GEMINI_API_KEY) MODEL=your-model-name PROVIDER=gemini Supported providers: openai google (Gemini) groq ollama mistral cohere anthropic together Ensure your project has the necessary dependencies: &quot;@types/node&quot;: &quot;20.x&quot;&quot;typescript&quot;: &quot;^5.8.3&quot;&quot;node.js&quot;: &quot;^v20.18.0&quot;&quot;npm&quot;: &quot;^11.4.1&quot;Visual Studio Code (v1.85+)  ","version":"Next","tagName":"h3"},{"title":"How to Use​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#how-to-use","content":" This action runs automatically on every commit. It analyzes code files changed in the commit and sends a file (commit_analysis_report.md) with analysis about performance and code smell suggestions to the root of projects.  ","version":"Next","tagName":"h3"},{"title":"Workflow Breakdown​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#workflow-breakdown","content":" The following steps describe the internal process behind CodeWise:  Git Commit Detection CodeWise watches the .git/logs/HEAD file to detect when a new commit is made. This enables real-time, non-intrusive monitoring of commit activity without requiring Git hooks. Extract Commit Information Once a commit is detected, the system extracts: Commit hash, author, date, and messageChanged files and corresponding diffs This information is formatted and saved in a temporary file (gitInput.txt) to serve as input for the language models. Invoke LLM Agents in Parallel CodeWise leverages a set of specialized agents (built on top of LangChain + LangGraph), each trained to analyze a specific dimension of the codebase: Architect Agent: Analyzes folder structure and determines the architectural pattern used (e.g., MVC, Clean Architecture).Integration Agent: Reviews module coupling and suggests integration improvements.SOLID Agent: Detects violations of SOLID principles and proposes corrections.Framework Analyst: Suggests alternative frameworks or improvements in the usage of existing ones.Design Pattern Advisor: Recommends design patterns suitable for scalability, reusability, or maintainability. Merge Results into Markdown Report The results from all LLMs are aggregated into a structured markdown report (commit_analysis_report.md), which includes individual sections for each agent’s findings. Clean Up and Await Next Commit After the report is generated, temporary files are deleted and the extension continues monitoring for future commits.  This automated cycle ensures that every commit is reviewed by AI before it even reaches the remote repository — enabling proactive quality control and faster feedback for developers.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#features","content":" Pre-commit Code Analysis Automatically analyzes code right after a local commit is made, ensuring issues are caught before pushing to the repository. LLM-Based Multi-Agent Architecture Utilizes multiple specialized Language Model agents (Architect, Integration Analyst, SOLID Reviewer, Design Pattern Advisor, etc.) working in parallel for deep, context-aware code evaluation. Support for Multiple LLM Providers Compatible with various LLM providers (OpenAI, Google Gemini, Ollama, Mistral, Groq, Cohere, and more) with plug-and-play extensibility via a factory pattern and reflection-based dynamic loading. Automatic Report Generation Produces a detailed markdown report (commit_analysis_report.md) after each commit, summarizing architectural insights, design flaws, and suggestions. No User Disruption Fully background operation – developers commit code as usual while CodeWise silently processes and reports. Multi-language Project Support Can analyze projects written in multiple programming languages, especially those structured around standard architectural patterns (e.g., MVC, DDD). Cross-Platform Compatibility Designed to work on Windows, macOS, and Linux environments (as long as Node.js and VS Code are installed). Modular and Extensible Design Easy to extend with new agent roles, models, or analysis types using a clean and maintainable architecture. CI/CD Ready CodeWise is built to support packaging and publishing via GitHub Actions, enabling streamlined deployment of new versions.  ","version":"Next","tagName":"h3"},{"title":"Requirements​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#requirements","content":" &quot;@types/node&quot;: &quot;20.x&quot; &quot;typescript&quot;: &quot;^5.8.3&quot; &quot;node.js&quot;: &quot;^v20.18.0&quot; &quot;npm&quot;: &quot;^11.4.1&quot; Visual Studio Code (v1.85+)  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/code_wise_extension/code_wise#usage","content":" Once installed and activated, CodeWise automatically monitors your Git workspace for new commits. When a commit is made, the extension triggers a background process that analyzes the committed code and generates a comprehensive report with architectural insights and improvement suggestions.  Follow these steps to use CodeWise:  Open a Git-based project in VS Code. Ensure the project is tracked by Git and has at least one workspace folder opened. Make a commit. When you commit code, CodeWise detects the change and analyzes it automatically. Wait for the analysis. Within seconds, CodeWise runs a set of LLM agents to analyze your code based on architecture, integration, design patterns, SOLID principles, and framework usage. Check the output report. A new file named commit_analysis_report.md will be created in the root of your project, containing a detailed summary of findings and suggestions. Review and refactor. Open the report to review the suggestions. Use the insights to refactor and improve your code quality before pushing to remote repositories.  The process is fully automated and non-intrusive. Developers commit code as usual; CodeWise works silently in the background. ","version":"Next","tagName":"h3"},{"title":"Analysis of improvement points based on software architecture concepts","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts","content":"","keywords":"","version":"Next"},{"title":"Scalability:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#scalability","content":" System ability to handle increased load without losing performance.  ","version":"Next","tagName":"h2"},{"title":"Problems:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#problems","content":" Analysis of PRs done synchronously and sequentially (one at a time).Coupled code that makes parallelism or use in multiple instances difficult.  ","version":"Next","tagName":"h3"},{"title":"Solutions​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#solutions","content":" Use processing queues (e.g. RabbitMQ, Redis, Celery) to handle many PRs at the same time.Run parallel workers to process multiple PRs simultaneously.Store analysis results in cache or database to avoid unnecessary reprocessing.Structure the Model to process multiple files in a distributed or asynchronous manner.  ","version":"Next","tagName":"h3"},{"title":"Maintainability:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#maintainability","content":" Ease of understanding, modifying and evolving the system over time  ","version":"Next","tagName":"h2"},{"title":"Problems:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#problems-1","content":" Code with mixed responsibilities (e.g. analysis logic within the controller).Lack of modularization of analysis rules.Lack of standardization for adding new sources (like Slack, GitLab, etc.).  ","version":"Next","tagName":"h3"},{"title":"Solutions:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#solutions-1","content":" Separate each layer well in MVC, avoiding mixing responsibilities.Create independent modules for each type of validation (e.g. style, security, performance).Use clear interfaces between layers, which allows you to change implementations without affecting the rest of the system.Document rules and flows to facilitate onboarding of new devs.  ","version":"Next","tagName":"h3"},{"title":"Testability:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#testability","content":" Ability to test the system in a simple, isolated and reliable way.  ","version":"Next","tagName":"h2"},{"title":"Problems:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#problems-2","content":" Coupled code with side effects (e.g. performs analysis and sends comments to GitHub in the same method).Lack of dependency injection (e.g. external APIs hardcoded in the code).Difficulty simulating scenarios without making real calls.  ","version":"Next","tagName":"h3"},{"title":"Solutions:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#solutions-2","content":" Separate business logic from code that interacts with external services.Use dependency injection so you can mock external calls.Create unit tests for each module (mainly Model ones).Have automated test coverage in Controllers.  ","version":"Next","tagName":"h3"},{"title":"Performance:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#performance","content":" How quickly and efficiently the system responds to operations.  ","version":"Next","tagName":"h2"},{"title":"Problems:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#problems-3","content":" Reanalyze all code with each PR, even if changes are small.Calling the Gemini API (or other agent) for each file separately (high cost and latency).Making unnecessary GitHub API calls.  ","version":"Next","tagName":"h3"},{"title":"Solutions:​","type":1,"pageTitle":"Analysis of improvement points based on software architecture concepts","url":"/leds-tools-public/code_wise/code_wise_extension/How was building/03-Analysis-of-improvement-points-based-on-software-architecture-concepts#solutions-3","content":" Incremental analysis, where actually modified files are processed.Group code snippets by context before sending to the agent, reducing calls.Cache the results of repeated analyzes.Monitor call response times and identify bottlenecks. ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/overview","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/code_wise/code_wise_extension/overview#overview","content":" Once installed and configured, CodeWise operates silently in the background. It monitors your Git repository for new commits and automatically triggers a set of intelligent agents that review the code changes, offering structured, insightful feedback saved directly into your workspace. ","version":"Next","tagName":"h3"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/code_wise_extension/project_managment#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tSend Feedback about a code to developer\tImplements a code review automaticaly seen Performance and Code Smell\t100\tImprove software developmen quality in 10% 2\tCreate Improvement/Refactor test on management program\tWhen a improment is detected a Improvement/Refactor Task is created on management software (e.g., Jira)\t90\tImprove software developmen quality and management in 15% 3\tSend informartion about quality of code to a database to improve the developer\tSend information about code smell and performance of code to a database to identify means to improve the developer that creates the code\t95\tImprove software developmen quality and management in 20%  ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/code_wise_extension/project_managment#general-planning","content":" Release 1.0 (Done): Send Feedback about a code to developerRelease 2.0 (Undefined): Create Improvement/Refactor test on management programRelease 3.0 (Undefined): Send informartion about quality of code to a database to improve the developerr  ","version":"Next","tagName":"h2"},{"title":"Release 1.0 - 01/11/2024​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/code_wise_extension/project_managment#release-10---01112024","content":" Goal: Send Feedback about a code to developer. Features: ID 1 Intercep and analyses a code when a pul request is performedSend information about analysis to a DIscord ChannelSend information about analysis to a pull request`s commentProblems: Spend much time to analysis many code, using GPT4 Oportunity Develop our IA to improve time and no spend money with GPT4 Deadline I 01/10/2023: Send Feedback about a code to developer.  ","version":"Next","tagName":"h2"},{"title":"Instalation","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/installation","content":"Instalation To use this action in your repository, follow the steps below: Install the extension locally Configure your .env file with the appropriate LLM credentials: (name of your provider)_API_KEY=your-api-key (ex. GEMINI_API_KEY) MODEL=your-model-name PROVIDER=gemini Supported providers: openai google (Gemini) groq ollama mistral cohere anthropic together Ensure your project has the necessary dependencies: &quot;@types/node&quot;: &quot;20.x&quot;&quot;typescript&quot;: &quot;^5.8.3&quot;&quot;node.js&quot;: &quot;^v20.18.0&quot;&quot;npm&quot;: &quot;^11.4.1&quot;Visual Studio Code (v1.85+)","keywords":"","version":"Next"},{"title":"CodeWise","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_lib/Overview CW-PR","content":"","keywords":"","version":"Next"},{"title":"Key Features​","type":1,"pageTitle":"CodeWise","url":"/leds-tools-public/code_wise/code_wise_lib/Overview CW-PR#key-features","content":" Title Generation: Creates clear and concise PR titles following the Conventional Commits standard.Description Generation: Writes detailed descriptions based on code changes.Technical Analysis: Posts a comment on the PR with an executive summary of architectural improvements, adherence to S.O.L.I.D. principles, and other quality points.Automation with Hooks: Integrates into your Git workflow to run automatically on every git commit and git push. ","version":"Next","tagName":"h2"},{"title":"How to Use","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_extension/howtouse","content":"How to Use This action runs automatically on every commit. It analyzes code files changed in the commit and sends a file (commit_analysis_report.md) with analysis about performance and code smell suggestions to the root of projects.","keywords":"","version":"Next"},{"title":"Mini-World To-Do List","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_lib/Mini-World CW-PR","content":"Mini-World To-Do List Video showing the tool in action: https://drive.google.com/file/d/1UEOB0TPu_5w2-L1Y-MoRSM9j5j_0AvyM/view?usp=sharing CodeWise aims to optimize the code review process in software projects, reducing the time spent on manual reviews and increasing the quality of the code delivered by development teams. It works in an integrated way with GitHub, automatically analyzing Pull Requests through generative language models. The solution identifies architectural improvements, possible code smells, violations of S.O.L.I.D. principles, and suggests appropriate design patterns. Additionally, it is capable of generating automatic PR titles and descriptions, contributing to clearer and more standardized documentation. The tool will be available as a library, installable via pip, and will feature integration hooks to act directly within repositories. Its central proposal is to reduce the manual effort of reviewers, standardize code architecture, and make the development process more efficient and sustainable.","keywords":"","version":"Next"},{"title":"Improvement Suggestions","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_lib/Suggestions for improvements CW-PR","content":"","keywords":"","version":"Next"},{"title":"Suggestion 1: Support for Local AI Models via Ollama​","type":1,"pageTitle":"Improvement Suggestions","url":"/leds-tools-public/code_wise/code_wise_lib/Suggestions for improvements CW-PR#suggestion-1-support-for-local-ai-models-via-ollama","content":" ","version":"Next","tagName":"h3"},{"title":"Concept​","type":1,"pageTitle":"Improvement Suggestions","url":"/leds-tools-public/code_wise/code_wise_lib/Suggestions for improvements CW-PR#concept","content":" Allow CodeWise to use language models (LLMs) running locally on the developer's machine through Ollama, instead of exclusively depending on the Google Gemini API.  Justification Security and Data Privacy: Companies with strict intellectual property policies could use the tool with the guarantee that their source code will never leave their machines.  Cost Reduction: We had issues with restrictions depending on the number of characters last semester, which limits the tool. We believe this can remove the need for paid API keys and the costs associated with Gemini API consumption, making the tool more efficient.  Offline Use: Developers could use the tool to analyze their code even without an internet connection.  Flexibility: It allows users to choose the model that best suits their hardware and needs (we find these relevant: Llama 3, Mistral, CodeLlama).  Some ideas/risks we find relevant:  -Hardware: Using local models requires more RAM and ideally a GPU, which can be a barrier for some users. -Depending on the model, the quality of the analysis may vary and could be lower than that of the Gemini API models. -It adds an extra setup step for the user (installing and managing Ollama).  ","version":"Next","tagName":"h3"},{"title":"Suggestion 2: \"Code Mentor\" Agent with Educational Suggestions​","type":1,"pageTitle":"Improvement Suggestions","url":"/leds-tools-public/code_wise/code_wise_lib/Suggestions for improvements CW-PR#suggestion-2-code-mentor-agent-with-educational-suggestions","content":" ","version":"Next","tagName":"h3"},{"title":"Concept​","type":1,"pageTitle":"Improvement Suggestions","url":"/leds-tools-public/code_wise/code_wise_lib/Suggestions for improvements CW-PR#concept-1","content":" We found the idea discussed with the professor to be interesting: adding a new AI agent to the team that, based on the analyses of S.O.L.I.D., architecture, and &quot;code smells&quot;, acts as a mentor, suggesting articles, courses, or videos to help the developer improve in areas where they are struggling.  Justification It transforms the tool from a simple &quot;code reviewer&quot; into a platform for professional growth and continuous learning. Instead of just pointing out an error (e.g., &quot;Violation of the Single Responsibility Principle&quot;), the tool also offers a path to the solution and learning. It would be extremely valuable for junior developers, who would receive personalized and contextualized guidance directly in their workflow. The tool could identify recurring knowledge gaps in a team, providing valuable insights for technical leadership.  Here is an idea we suggest:  Create a New Agent (config/agents.yaml):  Define a code_mentor_agent with the goal of &quot;analyzing the detected code problems and providing high-quality educational resources (links to articles, videos, or documentation) that help to understand and fix the root cause of the problem.&quot;  Create a New Task (config/tasks.yaml):  Define a mentoring_task that receives the consolidated output of the other analysis agents as its context.  The task would instruct the agent to identify the main concept behind the errors (e.g., &quot;SOLID&quot;, &quot;Clean Code&quot;, &quot;Design Patterns&quot;) and to find 1 or 2 relevant links for each concept.  Execute the New Task (codewise_lib/cw_runner.py):  After the main analysis_crew finishes, its output (task.output) would be used as input/context for a new Crew containing only the code_mentor_agent.  The output of the Mentor Agent would then be added to a new section in the Pull Request comment, with the title &quot;Learning Suggestions&quot;.  An idea would be to have a JSON file storing the history of errors after the analysis is done. In the same way the program creates a new folder in the user's repository to store the analyses with .md files, something similar could be done for the errors made in the repo.  Risks and Considerations Quality of Resources: The agent needs to be well-instructed to search for links from reliable sources to avoid suggesting poor-quality content. ","version":"Next","tagName":"h3"},{"title":"Code Wise Documentation","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/two_code_wises","content":"","keywords":"","version":"Next"},{"title":"Code Wise Extension​","type":1,"pageTitle":"Code Wise Documentation","url":"/leds-tools-public/code_wise/two_code_wises#code-wise-extension","content":" Code Wise Extension is a Visual Studio Code (VS Code) extension that uses AI to analyze code, identifying architectural improvements, SOLID principle violations, code smells, and suggesting design patterns.  ","version":"Next","tagName":"h2"},{"title":"Code Wise Lib​","type":1,"pageTitle":"Code Wise Documentation","url":"/leds-tools-public/code_wise/two_code_wises#code-wise-lib","content":" Code Wise Lib is a Python library that uses AI to analyze code and automate Pull Request documentation through Git hooks. ","version":"Next","tagName":"h2"},{"title":"VS Code Guide","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR","content":"","keywords":"","version":"Next"},{"title":"Using CodeWise in Visual Studio Code​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#using-codewise-in-visual-studio-code","content":" The CodeWise workflow is fully compatible with Visual Studio Code. Since the hooks are installed in your Git repository, they will be triggered whether you use the command line or the editor's graphical interface.  There are two main ways to use Git in VS Code, and both activate CodeWise.    ","version":"Next","tagName":"h2"},{"title":"Method 1: Using the Integrated Terminal (Recommended)​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#method-1-using-the-integrated-terminal-recommended","content":" This is the most direct and recommended way, as you will see all of CodeWise's output in real-time.  ","version":"Next","tagName":"h2"},{"title":"1. Open the Integrated Terminal​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#1-open-the-integrated-terminal","content":" You can open a terminal directly in VS Code using the shortcut Ctrl + (backtick) or by going to theTerminal&gt;New Terminal` menu.  ","version":"Next","tagName":"h3"},{"title":"2. Follow the Standard Flow​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#2-follow-the-standard-flow","content":" With the terminal open, the steps are exactly the same as in the main guide:  Add your changes: git add . At this point, codewise-lint can be run manually for a preliminary analysis. Make the commit: git commit -m &quot;implements new feature&quot; The pre-commit hook will be triggered, and you will see the codewise-lint analysis directly in the terminal. Push to GitHub: git push The pre-push hook will be triggered. Watch the terminal to see the Pull Request creation and to answer any questions about the remote (origin or upstream).    ","version":"Next","tagName":"h3"},{"title":"Method 2: Using the GUI (Source Control Panel)​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#method-2-using-the-gui-source-control-panel","content":" If you prefer to use the visual interface for Git in VS Code, CodeWise will also work. The key is to keep an eye on the integrated terminal to see the tool's messages.  ","version":"Next","tagName":"h2"},{"title":"1. Stage Your Changes​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#1-stage-your-changes","content":" Open the Source Control panel in the sidebar (icon with three connected dots).Modified files will appear under &quot;Changes&quot;. Click the + icon next to each file to stage them (equivalent to git add).  ","version":"Next","tagName":"h3"},{"title":"2. Make the Commit​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#2-make-the-commit","content":" At the top of the Source Control panel, type your commit message in the text box. Click the &quot;check&quot; icon or press Ctrl + Enter to commit. ⚠️ Attention: At this moment, the pre-commit hook will be triggered in the background. Open the Integrated Terminal (Ctrl + ) to see the output from codewise-lint`.  ","version":"Next","tagName":"h3"},{"title":"3. Push to GitHub​","type":1,"pageTitle":"VS Code Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in VSCODE CW-PR#3-push-to-github","content":" After committing, a &quot;Sync Changes&quot; or &quot;Publish Branch&quot; button will appear in the Source Control panel. Click it to send your changes. ⚠️ Attention: The pre-push hook will be triggered now. It is essential that you watch the Integrated Terminal, as codewise-pr may ask questions (like the choice between origin and upstream) that will require your input to continue. The push process in the GUI will only complete after the CodeWise hook finishes its execution. ","version":"Next","tagName":"h3"},{"title":"Installation Guide","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/code_wise_lib/Using in CLI CW-PR","content":"","keywords":"","version":"Next"},{"title":"Installation Guide​","type":1,"pageTitle":"Installation Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in CLI CW-PR#installation-guide","content":" Follow these steps to install and configure CodeWise in any of your repositories.    Lib: https://pypi.org/project/codewise-lib  ","version":"Next","tagName":"h2"},{"title":"Step 1: Prerequisites​","type":1,"pageTitle":"Installation Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in CLI CW-PR#step-1-prerequisites","content":" Before you start, ensure you have the following tools installed on your system:  Python (version 3.11 or higher).Git.GitHub CLI (gh): After installing from (https://cli.github.com), log in with your GitHub account by running gh auth login in your terminal (you only need to do this once per PC).    ","version":"Next","tagName":"h3"},{"title":"Step 2: Setting Up Your Repository​","type":1,"pageTitle":"Installation Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in CLI CW-PR#step-2-setting-up-your-repository","content":" For each new repository where you want to use CodeWise, follow the steps below.  &quot;It's always a good idea to create a virtual environment in the root folder of the new repository to avoid dependency conflicts.&quot;    2.1 Create and Use a Virtual Environment​  To avoid conflicts with other Python projects, use a virtual environment (venv).  To Create the Environment: This command creates a .venv folder with a clean Python installation. Do this only once per repository.Remember that &quot;.venv&quot; is the name of the created folder; you can choose any other name for it.  (inside the repository root where the .git folder is)  # On Windows py -m venv .venv # On Linux/WSL python3 -m venv .venv   To Activate the Environment: Whenever you work on the project, you need to activate the environment. Tip for Windows/PowerShell: If the activation command gives an execution policy error, run this command first: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # On Windows (PowerShell) .\\.venv\\Scripts\\activate # On Linux/WSL source .venv/bin/activate You'll know it worked because the name (.venv) will appear at the beginning of your terminal line.    2.2 Install the CodeWise Tool​  With the virtual environment active, install the library with pip.  pip install codewise-lib   It may take a while to install all dependencies the first time.  After installing the library, you can confirm everything is working with the command codewise-help    2.3 Configure the API Key (.env)​  For the AI to work, you need to configure your Google Gemini API key.  In the root of your project, create a file called .env. You can use the following commands in the terminal: Windows notepad .env Linux/WSL touch .env &amp;&amp; nano .env Inside the .env file, paste the following content, add your key, and save: GEMINI_API_KEY=YOUR_KEY_HERE MODEL_NAME=gemini-2.0-flash   ⚠️ Important: Remember to add the .env file to your .gitignore so you don’t push your secret key to GitHub, and make sure it’s an actual &quot;ENV file&quot; and not .txt or something similar.    ","version":"Next","tagName":"h3"},{"title":"Important Note: The CodeWise tool expects your remotes to follow the standard GitHub convention:​","type":1,"pageTitle":"Installation Guide","url":"/leds-tools-public/code_wise/code_wise_lib/Using in CLI CW-PR#important-note-the-codewise-tool-expects-your-remotes-to-follow-the-standard-github-convention","content":" origin: Should point to your personal fork of the repository.  upstream: (if you add it to the repository) Should point to the main repository you forked from.  If you start a brand-new repository from scratch, you must do an initial push with git push --no-verify before using the tool so that the GH CLI works properly when creating Pull Requests.  2.4 Now — only once — Activate Automation in the Repository with a command.​  In the root of the project where the .git folder is, run:  codewise-init --all   Use this command whenever you want to change where the PULL REQUEST WILL BE CREATED in the pre-push hooks, because if you add an upstream remote you will need to switch which remote the PR will be generated for.  Here is the Pull Request target configuration:  If your repository has an upstream remote configured, the installer will ask after you run codewise-init --all to set the default pre-push hook behavior:  An 'upstream' remote was detected. What should be the default behavior of 'git push' for this repository? 1: Create Pull Request in 'origin' (your fork) 2: Create Pull Request in 'upstream' (main project) Choose the default (1 or 2):   Your choice will be saved in the hook, and you won’t need to worry about it again. If there is no upstream, it will default to origin.  You’ll see a success message confirming that automation is active.  With this command the pre-commit and pre-push files will already have been added to your repository hooks.    Everything is now working in the repository you configured. If you want to install it in a new repository, just repeat the steps.  Using CodeWise  With the configuration complete, you now have access to the codewise-lint and codewise-pr commands both manually and automatically after installing the hooks.  Add your changes After modifying your files, add them to the staging area: git add . Here you can run the codewise-lint command to analyze the files and make adjustments before committing. Commit your changes git commit -m &quot;implement new feature&quot; At this moment, the pre-commit hook will be triggered, and codewise-lint will run a quick analysis in your terminal. Push to GitHub git push Now, the pre-push hook will be triggered. codewise-pr will ask which remote you want to push to if there is an upstream besides your origin, and then it will create/update your Pull Request with a title, description, and technical analysis generated by AI. ","version":"Next","tagName":"h2"},{"title":"How to Contribute","type":0,"sectionRef":"#","url":"/leds-tools-public/made/advanced-topics/made_contribute","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#getting-started","content":" ","version":"Next","tagName":"h2"},{"title":"Development Setup​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#development-setup","content":" Fork the repositoryClone your fork locallyInstall dependencies: npm installBuild the project: npm run buildRun tests: npm test  ","version":"Next","tagName":"h3"},{"title":"Repository Structure​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#repository-structure","content":" leds-tools-made - VS Code extension and CLIleds-tools-made-lib - Core processing libraryleds-tools-made-docker - Containerized runtimeleds-tools-made-githubaction - GitHub Actions automation  ","version":"Next","tagName":"h3"},{"title":"Priority Feature Requests​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#priority-feature-requests","content":" We've identified several key improvements that would make MADE significantly better. These features represent excellent opportunities for contributors to make meaningful impact.  ","version":"Next","tagName":"h2"},{"title":"1. Avoid Duplication of Issues on GitHub​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#1-avoid-duplication-of-issues-on-github","content":" Problem: Currently, running the GitHub integration multiple times creates duplicate issues.  Solution Needed:  Compare existing repository issues before creationSkip issues that already exist based on title/description matchingProvide option to update existing issues instead of creating duplicates  Implementation Approach:  class GitHubDuplicationHandler { async getExistingIssues(org: string, repo: string): Promise&lt;GitHubIssue[]&gt; { // Query existing issues from repository } async shouldCreateIssue(newIssue: Issue, existingIssues: GitHubIssue[]): Promise&lt;boolean&gt; { // Compare titles, descriptions, labels // Return false if similar issue exists } }   Impact: Prevents cluttered repositories and improves workflow reliability.  ","version":"Next","tagName":"h3"},{"title":"2. Allow Use of GitHub Templates​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#2-allow-use-of-github-templates","content":" Problem: Issues are created with basic formatting, missing repository-specific templates.  Solution Needed:  Support custom issue templates for different issue types (Epic, Story, Task)Read templates from local folder structureAllow variable substitution in templates  Implementation Approach:  project/ ├── .made-templates/ │ ├── epic.md # Epic issue template │ ├── story.md # Story issue template │ └── task.md # Task issue template ├── project.made └── .env   Template Example:  &lt;!-- epic.md --&gt; ## Epic: {{title}} **Description**: {{description}} **Acceptance Criteria**: {{#each criterions}} - [ ] {{this}} {{/each}} **Related Stories**: &lt;!-- Will be populated automatically --&gt;   Impact: Better integration with existing GitHub workflows and repository standards.  ","version":"Next","tagName":"h3"},{"title":"3. Event-Based Programming Paradigm​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#3-event-based-programming-paradigm","content":" Problem: Current implementation uses condition-checking patterns, making it harder to extend and maintain.  Solution Needed:  Refactor core architecture to use event-driven patternsImplement observer pattern for component processingEnable plugin-based extensions through events  Implementation Approach:  interface MadeEvent { type: string; data: any; timestamp: Date; } class EventBus { private listeners: Map&lt;string, Function[]&gt; = new Map(); emit(event: MadeEvent): void { const handlers = this.listeners.get(event.type) || []; handlers.forEach(handler =&gt; handler(event)); } on(eventType: string, handler: Function): void { // Register event listener } } // Usage eventBus.on('backlog.processed', (event) =&gt; { // Generate backlog documentation }); eventBus.on('sprint.created', (event) =&gt; { // Update sprint metrics });   Impact: Improved extensibility, better separation of concerns, and easier testing.  ","version":"Next","tagName":"h3"},{"title":"4. Improve GitHub Integration Mapping​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#4-improve-github-integration-mapping","content":" Problem: Current GitHub integration doesn't leverage GitHub's native features optimally.  Solution Needed:  Better mapping of MADE components to GitHub native structuresUtilize GitHub Projects V2 custom fields more effectivelyImprove milestone and release management integration  Current vs Improved Mapping:  MADE Component\tCurrent GitHub Mapping\tImproved MappingEpic\tIssue with &quot;Epic&quot; label\tEpic issue with linked children Story\tIssue with &quot;Story&quot; label\tStory with proper parent Epic reference Task\tIssue with &quot;Task&quot; label\tTask with Story parent and proper assignees Sprint\tMilestone\tGitHub Project iteration field Process\tNot mapped\tGitHub Project template Dependencies\tDescription text\tGitHub issue blocking relationships  Implementation Ideas:  class ImprovedGitHubMapper { async createEpicWithChildren(epic: Epic): Promise&lt;void&gt; { // Create parent Epic issue // Create child Story issues with proper linking // Use GitHub's issue hierarchy features } async mapSprintToIteration(sprint: TimeBox): Promise&lt;void&gt; { // Use GitHub Projects V2 iteration fields // Better sprint planning integration } async setupDependencyBlocking(task: Task): Promise&lt;void&gt; { // Use GitHub's native issue blocking // Create proper dependency chains } }   Impact: More native GitHub experience, better project management integration.  ","version":"Next","tagName":"h3"},{"title":"Additional Contribution Opportunities​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#additional-contribution-opportunities","content":" ","version":"Next","tagName":"h2"},{"title":"Documentation Improvements​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#documentation-improvements","content":" Add more comprehensive examplesCreate video tutorialsImprove error messages and help text  ","version":"Next","tagName":"h3"},{"title":"Testing Enhancement​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#testing-enhancement","content":" Increase test coverageAdd integration tests with real GitHub APIPerformance testing for large projects  ","version":"Next","tagName":"h3"},{"title":"Feature Extensions​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#feature-extensions","content":" Support for more project management tools (Jira, Azure DevOps)Custom chart types and metricsAdvanced dependency analysis  ","version":"Next","tagName":"h3"},{"title":"Developer Experience​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#developer-experience","content":" Better error handling and debuggingImproved CLI output and progress indicatorsHot reload for development  ","version":"Next","tagName":"h3"},{"title":"Contribution Guidelines​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#contribution-guidelines","content":" ","version":"Next","tagName":"h2"},{"title":"Code Style​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#code-style","content":" Follow TypeScript best practicesUse meaningful variable and function namesAdd comprehensive JSDoc commentsInclude unit tests for new features  ","version":"Next","tagName":"h3"},{"title":"Pull Request Process​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#pull-request-process","content":" Create feature branch from mainImplement feature with testsUpdate documentationSubmit PR with clear descriptionAddress review feedback  ","version":"Next","tagName":"h3"},{"title":"Testing Requirements​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#testing-requirements","content":" Unit tests for new functionalityIntegration tests for GitHub featuresManual testing with example .made filesPerformance impact assessment  ","version":"Next","tagName":"h3"},{"title":"Getting Help​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#getting-help","content":" Open an issue for questions or bug reportsCheck existing issues before creating new onesJoin community discussionsReview architecture documentation first  ","version":"Next","tagName":"h2"},{"title":"Recognition​","type":1,"pageTitle":"How to Contribute","url":"/leds-tools-public/made/advanced-topics/made_contribute#recognition","content":" Contributors will be:  Listed in project contributorsCredited in release notesInvited to maintainer discussions for significant contributions  These improvements would make MADE a more robust, user-friendly, and professionally viable project management tool. Each represents a meaningful opportunity to contribute to an active open-source project. ","version":"Next","tagName":"h2"},{"title":"Tool vs Library Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib","content":"","keywords":"","version":"Next"},{"title":"MADE Tool (leds-tools-made)​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#made-tool-leds-tools-made","content":" ","version":"Next","tagName":"h2"},{"title":"Purpose​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#purpose","content":" The VS Code extension and CLI interface that provides user interaction and DSL parsing.  ","version":"Next","tagName":"h3"},{"title":"Key Responsibilities​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#key-responsibilities","content":" DSL Parsing: Interprets .made files using Langium grammarUser Interface: VS Code extension with syntax highlighting and commandsCLI Interface: Command-line tool for automationIntegration: Connects user input to the processing library  ","version":"Next","tagName":"h3"},{"title":"Core Components​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#core-components","content":" application/ # Domain applications (Project, Team, TimeBox, etc.) language/ # Langium DSL grammar and parser static/ # Monaco Editor UI files cli/ # Command-line interface extension/ # VS Code extension code   ","version":"Next","tagName":"h3"},{"title":"Technologies​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#technologies","content":" Langium: DSL creation and parsingVS Code Extension API: Editor integrationNode.js: CLI and backend processingTypeScript: Type-safe development  ","version":"Next","tagName":"h3"},{"title":"MADE Library (leds-tools-made-lib)​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#made-library-leds-tools-made-lib","content":" ","version":"Next","tagName":"h2"},{"title":"Purpose​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#purpose-1","content":" The core processing engine that generates documentation, charts, and handles GitHub integration.  ","version":"Next","tagName":"h3"},{"title":"Key Responsibilities​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#key-responsibilities-1","content":" Data Processing: Transforms parsed DSL into actionable data structuresDocumentation Generation: Creates markdown reports and documentationVisualization: Generates SVG charts and dependency diagramsGitHub Integration: Pushes data to GitHub Issues and Projects  ","version":"Next","tagName":"h3"},{"title":"Core Components​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#core-components-1","content":" models/ # Data models (Project, Sprint, Issue, etc.) markdown/ # Documentation generation services chart/ # SVG chart generators (CFD, throughput, dependencies) util/ # Common utilities and helpers service/ # GitHub API integration   ","version":"Next","tagName":"h3"},{"title":"Key Services​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#key-services","content":" MarkdownService: Orchestrates documentation generationGitHubService: Handles GitHub API operationsChartGenerators: Creates visual diagramsDependencyAnalyzer: Analyzes task relationships  ","version":"Next","tagName":"h3"},{"title":"Separation Benefits​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#separation-benefits","content":" ","version":"Next","tagName":"h2"},{"title":"1. Modularity​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#1-modularity","content":" Tool focuses on user interactionLibrary focuses on data processingClear separation of concerns  ","version":"Next","tagName":"h3"},{"title":"2. Reusability​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#2-reusability","content":" Library can be used independentlyMultiple frontends can use the same libraryDifferent deployment scenarios supported  ","version":"Next","tagName":"h3"},{"title":"3. Maintainability​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#3-maintainability","content":" Easier to test individual componentsClear API boundariesIndependent versioning possible  ","version":"Next","tagName":"h3"},{"title":"4. Extensibility​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#4-extensibility","content":" New frontends can be added easilyLibrary features can be extended independentlyPlugin architecture support  ","version":"Next","tagName":"h3"},{"title":"Integration Flow​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#integration-flow","content":"   ","version":"Next","tagName":"h2"},{"title":"Usage Patterns​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#usage-patterns","content":" ","version":"Next","tagName":"h2"},{"title":"Direct Library Usage​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#direct-library-usage","content":" import { ReportManager } from 'made-lib-beta'; const reportManager = new ReportManager(); await reportManager.githubPush(token, org, repo, project, epics, stories, tasks);   ","version":"Next","tagName":"h3"},{"title":"Tool-mediated Usage​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_vs_lib#tool-mediated-usage","content":" # Via CLI made-cli github project.made # Via VS Code Extension # Right-click &gt; Generate GitHub Issues   This architecture allows MADE to be both user-friendly through the tool interface and powerful through direct library integration. ","version":"Next","tagName":"h3"},{"title":"Tool Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture","content":"","keywords":"","version":"Next"},{"title":"Architecture Overview​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#architecture-overview","content":"   ","version":"Next","tagName":"h2"},{"title":"Core Components​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#core-components","content":" ","version":"Next","tagName":"h2"},{"title":"1. Language Definition (language/)​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#1-language-definition-language","content":" DSL Grammar (made.langium)​  grammar Made entry Model: (project=Project) (components+=(Team|Process|Backlog|TimeBox|Roadmap))*   Key Files​  made.langium - Main grammar definitionbacklog.langium - Backlog-specific grammarteam.langium - Team structure grammarprocess.langium - Process definition grammarroadmap.langium - Roadmap and milestone grammar  Generated Code​  ast.ts - AST node definitionsgrammar.ts - Parser implementationmodule.ts - Language service configuration  ","version":"Next","tagName":"h3"},{"title":"2. Application Layer (application/)​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#2-application-layer-application","content":" Application Manager​  class ApplicationManager { private applications: Map&lt;string, BaseApplication&gt; = new Map(); async initializeApplications() { // Initialize domain-specific applications this.applications.set('project', new ProjectApplication()); this.applications.set('backlog', new BacklogApplication()); this.applications.set('team', new TeamApplication()); // ... } }   Domain Applications​  ProjectApplication: Project metadata managementBacklogApplication: Epic/Story/Task processingTeamApplication: Team member and role managementTimeBoxApplication: Sprint and iteration handlingProcessApplication: Workflow and process definition  ","version":"Next","tagName":"h3"},{"title":"3. VS Code Extension (extension/)​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#3-vs-code-extension-extension","content":" Main Extension File​  export function activate(context: vscode.ExtensionContext): void { registerGeneratorCommand(context); client = startLanguageClient(context); } function registerGeneratorCommand(context: vscode.ExtensionContext): void { const generateDocumentation = () =&gt; { const filepath = vscode.window.activeTextEditor?.document.fileName; if(filepath) { generateAction(filepath, { only_project_documentation: true }); } }; context.subscriptions.push( vscode.commands.registerCommand(&quot;made.generateDocumentation&quot;, generateDocumentation) ); }   Features​  Syntax Highlighting: Based on Langium grammarIntelliSense: Auto-completion and error detectionCommands: Right-click context menu actionsLanguage Server: Real-time validation  ","version":"Next","tagName":"h3"},{"title":"4. CLI Interface (cli/)​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#4-cli-interface-cli","content":" Main CLI Entry Point​  export const generateAction = async (fileName: string, opts: GenerateOptions): Promise&lt;void&gt; =&gt; { const services = createMadeServices(NodeFileSystem).Made; const model = await extractAstNode&lt;Model&gt;(fileName, services); generate(model, fileName, opts.destination, opts); }; export const githubPushAction = async (fileName: string, token: string, org: string, repo: string): Promise&lt;void&gt; =&gt; { const services = createMadeServices(NodeFileSystem).Made; const model = await extractAstNode&lt;Model&gt;(fileName, services); // Process components and push to GitHub const reportManager = new ReportManager(); await reportManager.githubPush(token, org, repo, project, epics, stories, tasks); };   Command Structure​  generate - Documentation generationgithub - GitHub integration--help - Command help  ","version":"Next","tagName":"h3"},{"title":"Processing Flow​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#processing-flow","content":" ","version":"Next","tagName":"h2"},{"title":"1. File Parsing​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#1-file-parsing","content":" // Parse .made file into AST const services = createMadeServices(NodeFileSystem).Made; const model = await extractAstNode&lt;Model&gt;(fileName, services);   ","version":"Next","tagName":"h3"},{"title":"2. Component Processing​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#2-component-processing","content":" // Extract different component types const backlogs = model.components.filter(c =&gt; c.$type === 'Backlog'); const teams = model.components.filter(c =&gt; c.$type === 'Team'); const timeboxes = model.components.filter(c =&gt; c.$type === 'TimeBox');   ","version":"Next","tagName":"h3"},{"title":"3. Data Transformation​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#3-data-transformation","content":" // Transform AST to domain objects const { epics, stories, tasks, backlogList } = processBacklogs(backlogs, assigneeMap); const teamList = processTeams(teamsRaw); const project = processProject(model.project);   ","version":"Next","tagName":"h3"},{"title":"4. Output Generation​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#4-output-generation","content":" // Generate outputs via library const reportManager = new ReportManager(); await reportManager.createReport(dbPath); // Documentation await reportManager.githubPush(/* GitHub integration */);   ","version":"Next","tagName":"h3"},{"title":"Key Technologies​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#key-technologies","content":" ","version":"Next","tagName":"h2"},{"title":"Langium Framework​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#langium-framework","content":" Grammar Definition: Declarative DSL syntaxParser Generation: Automatic parser creationLanguage Server: VS Code integrationValidation: Real-time error checking  ","version":"Next","tagName":"h3"},{"title":"TypeScript Benefits​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#typescript-benefits","content":" Type Safety: Compile-time error detectionIntelliSense: Better development experienceRefactoring: Safe code changesDocumentation: Self-documenting code  ","version":"Next","tagName":"h3"},{"title":"Extension Points​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#extension-points","content":" ","version":"Next","tagName":"h2"},{"title":"Custom Applications​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#custom-applications","content":" class CustomApplication extends BaseApplication { async process(component: CustomComponent): Promise&lt;void&gt; { // Custom processing logic } }   ","version":"Next","tagName":"h3"},{"title":"Grammar Extensions​","type":1,"pageTitle":"Tool Architecture","url":"/leds-tools-public/made/advanced-topics/made_tool_architecture#grammar-extensions","content":" // Add new component types CustomComponent: 'custom' id=ID '{' 'property:' property=STRING '}';   This architecture provides a solid foundation for DSL processing while maintaining flexibility for extensions and customizations. ","version":"Next","tagName":"h3"},{"title":"Library Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture","content":"","keywords":"","version":"Next"},{"title":"Architecture Overview​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#architecture-overview","content":"   ","version":"Next","tagName":"h2"},{"title":"Core Components​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#core-components","content":" ","version":"Next","tagName":"h2"},{"title":"1. Data Models (model/models.ts)​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#1-data-models-modelmodelsts","content":" Primary Models​  interface Project { id: string; name: string; description?: string; startDate?: string; dueDate?: string; } interface Issue { id: string; type: string; subtype: string; title: string; description?: string; labels?: string[]; assignee?: TeamMember; dependencies?: string[]; } interface TimeBox { id: string; name: string; description?: string; startDate?: string; endDate?: string; status?: string; sprintItems: SprintItem[]; }   ","version":"Next","tagName":"h3"},{"title":"2. Report Manager (index.ts)​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#2-report-manager-indexts","content":" Main Entry Point​  export class ReportManager { // Generate documentation public createReport(dbPath: string): void { const markdownService = new MarkdownService(dbPath); markdownService.createManagementDocumentation(); } // GitHub ETL (Extract, Transform, Load) public async githubETL(token: string, org: string, project: string): Promise&lt;void&gt; { GitHubTokenManager.initialize(token); const githubService = new GitHubService(); await githubService.ETLProject(org, project); await githubService.ETLIssue(org, project); await githubService.ETLBacklog(org, project); await githubService.ETLTimeBox(org, project); await githubService.ETLTeam(org); } // Push to GitHub public async githubPush(/* parameters */): Promise&lt;void&gt; { GitHubTokenManager.initialize(token); const pushService = new GitHubPushService(); await pushService.fullPush(org, repo, project, epics, stories, tasks); } }   ","version":"Next","tagName":"h3"},{"title":"3. Markdown Services (markdown/)​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#3-markdown-services-markdown","content":" MarkdownService Orchestrator​  class MarkdownService { constructor(private dbPath: string) {} createManagementDocumentation(): void { this.generateBacklogDocumentation(); this.generateTimeBoxDocumentation(); this.generateRoadmapDocumentation(); this.generateProjectSummary(); } private generateBacklogDocumentation(): void { const backlogService = new MarkdownBacklogService(this.dbPath); backlogService.generate(); } }   Specialized Services​  MarkdownBacklogService: Epic/Story/Task documentationMarkdownTimeBoxService: Sprint and iteration reportsMarkdownRoadmapService: Milestone and release planningMarkdownTeamService: Team structure and assignments  ","version":"Next","tagName":"h3"},{"title":"4. Chart Generation (chart/)​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#4-chart-generation-chart","content":" Chart Generators​  // Cumulative Flow Diagram class CumulativeFlowDiagram { generate(timeboxes: TimeBox[]): string { // Generate SVG chart showing work progress return svgContent; } } // Project Throughput class ProjectThroughputGenerator { generate(issues: Issue[]): string { // Generate throughput analysis chart return svgContent; } } // Dependency Analysis class ProjectDependencyAnalyzer { generateMermaidDiagram(issues: Issue[]): string { // Generate Mermaid dependency diagram return mermaidContent; } }   ","version":"Next","tagName":"h3"},{"title":"5. GitHub Integration (service/)​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#5-github-integration-service","content":" GitHubService (Data Extraction)​  class GitHubService { async ETLProject(org: string, projectName: string): Promise&lt;Project&gt; { const githubProject = await this.getProjectByTitle(org, projectName); const project = await this.mapGitHubProjectToProject(githubProject); // Save to local data store FileSystemRepository.save('project.json', project); return project; } async ETLIssue(org: string, projectName: string): Promise&lt;Issue[]&gt; { // Extract issues from GitHub // Transform to internal format // Load into local storage } }   GitHubPushService (Data Publishing)​  class GitHubPushService { async fullPush( org: string, repo: string, project: Project, epics: Issue[], stories: Issue[], tasks: Issue[] ): Promise&lt;void&gt; { const projectId = await this.pushProject(org, project); for (const epic of epics) { await this.pushIssue(org, repo, projectId, epic); } // ... push stories and tasks } private async pushProject(org: string, project: Project): Promise&lt;string&gt; { const mutation = ` mutation CreateProject($input: CreateProjectV2Input!) { createProjectV2(input: $input) { projectV2 { id } } } `; return await this.graphqlRequest(mutation, variables); } }   ","version":"Next","tagName":"h3"},{"title":"Data Flow​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#data-flow","content":" ","version":"Next","tagName":"h2"},{"title":"1. Input Processing​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#1-input-processing","content":" // From MADE Tool or direct usage const project: Project = { /* project data */ }; const issues: Issue[] = [ /* issues data */ ];   ","version":"Next","tagName":"h3"},{"title":"2. Documentation Generation​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#2-documentation-generation","content":" // Create comprehensive documentation const markdownService = new MarkdownService('./data'); markdownService.createManagementDocumentation(); // Output: // - 01_project_overview.md // - 02_backlogs.md // - 03_sprints.md // - 04_roadmap.md // - charts/dependencies.svg   ","version":"Next","tagName":"h3"},{"title":"3. GitHub Integration​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#3-github-integration","content":" // Push to GitHub await reportManager.githubPush(token, org, repo, project, epics, stories, tasks); // Creates: // - GitHub Issues for each Epic/Story/Task // - GitHub Project with proper structure // - Milestones for roadmap items // - Team assignments and labels   ","version":"Next","tagName":"h3"},{"title":"Key Features​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#key-features","content":" ","version":"Next","tagName":"h2"},{"title":"Repository Pattern​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#repository-pattern","content":" interface Repository&lt;T&gt; { save(filename: string, data: T): void; load(filename: string): T; exists(filename: string): boolean; } class FileSystemRepository&lt;T&gt; implements Repository&lt;T&gt; { // File-based data persistence }   ","version":"Next","tagName":"h3"},{"title":"Dependency Analysis​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#dependency-analysis","content":" class DependencyGraph { addNode(id: string, dependencies: string[]): void; detectCycles(): string[][]; getTopologicalOrder(): string[]; }   ","version":"Next","tagName":"h3"},{"title":"Chart Generation Pipeline​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#chart-generation-pipeline","content":" Data Extraction: Pull relevant metrics from data modelsProcessing: Calculate charts data pointsRendering: Generate SVG or Mermaid outputIntegration: Embed in markdown documentation  ","version":"Next","tagName":"h3"},{"title":"Extension Points​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#extension-points","content":" ","version":"Next","tagName":"h2"},{"title":"Custom Chart Generators​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#custom-chart-generators","content":" class CustomChartGenerator extends BaseChartGenerator { generate(data: any[]): string { // Custom chart logic return svgContent; } }   ","version":"Next","tagName":"h3"},{"title":"Custom Markdown Services​","type":1,"pageTitle":"Library Architecture","url":"/leds-tools-public/made/advanced-topics/made_lib_architecture#custom-markdown-services","content":" class CustomMarkdownService { constructor(private dbPath: string) {} generateCustomReport(): void { // Custom documentation logic } }   This architecture provides a robust foundation for data processing while maintaining extensibility for custom requirements. ","version":"Next","tagName":"h3"},{"title":"Artifact Map","type":0,"sectionRef":"#","url":"/leds-tools-public/made/advanced-topics/made_artifact_map","content":"","keywords":"","version":"Next"},{"title":"Input → Output Mapping​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#input--output-mapping","content":" ","version":"Next","tagName":"h2"},{"title":"1. Documentation Generation​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#1-documentation-generation","content":" From Project Component​  project myproject { name: &quot;My Project&quot; description: &quot;Project description&quot; startDate: 2024-01-01 dueDate: 2024-12-31 }   Generates:  01_overview.md - Project metadata, metrics, and forecastIncludes consolidated sprint metrics tableProject completion probability analysisCumulative Flow Diagram (SVG)  From Team Component​  team developers { name: &quot;Development Team&quot; teammember john { name: &quot;John Doe&quot; email: &quot;john@company.com&quot; } }   Generates:  Team data in data/db/team.jsonTeam assignments in sprint documentationTeam member information integrated in sprint reports  From Backlog Component​  backlog productbacklog { epic authentication { story login { task loginform { /* ... */ } } } }   Generates:  02_backlogs.md - Main backlog documentation (may be empty if no standalone backlogs)data/db/backlog.json - Structured backlog datadata/db/issue.json - All issues (epics, stories, tasks) with dependenciesDependency analysis in sprint documentation  From Sprint Component​  sprint sprint1 { sprintbacklog items { item productbacklog.authentication.login.loginform { assignee: developers.john status: TODO } } }   Generates:  sprints/{sprint-name}.md - Individual sprint reports with: Sprint backlog table with assignees and statusGantt chart (Mermaid)Dependency analysis with visual graphSprint forecast and probability analysisCumulative Flow DiagramThroughput chart data/db/timebox.json - Structured sprint data  From Roadmap Component​  roadmap projectroadmap { milestone v1 { release alpha { item: productbacklog.authentication } } }   Generates:  03_roadmap.md - Roadmap documentation with: Progress overview with milestone statisticsMilestone details with releases and associated issuesTimeline view of milestones and releases data/db/roadmap.json - Structured roadmap data  ","version":"Next","tagName":"h3"},{"title":"2. GitHub Integration​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#2-github-integration","content":" Issues Creation​  MADE Component\tGitHub ArtifactEpic\tGitHub Issue with &quot;Epic&quot; label Story\tGitHub Issue with &quot;Story&quot; label Task\tGitHub Issue with &quot;Task&quot; label  Project Structure​  MADE Component\tGitHub ArtifactProject\tGitHub Project V2 Sprint\tGitHub Milestone Team\tGitHub Team (if org permissions)  Relationships​  MADE Relationship\tGitHub ImplementationTask dependencies\tIssue references in description Sprint assignments\tIssue assignee + milestone Epic → Story → Task\tParent-child issue linking  ","version":"Next","tagName":"h3"},{"title":"3. Chart Generation​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#3-chart-generation","content":" Dependency Charts​  Input: Task dependencies from backlogs  task authentication { depends: productbacklog.authentication.login.loginform }   Output: Mermaid dependency graphs embedded in sprint documentation    Sprint Forecast Charts​  Input: Sprint items with status and completion data  item productbacklog.task { status: DONE completedDate: 2024-02-10 }   Output: Embedded SVG charts in sprint documentation:  charts/cfd-{sprint-name}.svg - Cumulative Flow Diagramcharts/throughput-{sprint-name}.svg - Throughput analysis  Project-level Charts​  Input: All sprint data across the projectOutput:  project-cfd.svg - Overall project Cumulative Flow Diagram  ","version":"Next","tagName":"h3"},{"title":"File Structure Output​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#file-structure-output","content":" ","version":"Next","tagName":"h2"},{"title":"Complete Generation Result​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#complete-generation-result","content":" project/ ├── 01_overview.md # Project overview with metrics and forecast ├── 02_backlogs.md # Backlog documentation (may be minimal) ├── 03_roadmap.md # Roadmap with milestones and releases ├── _category_.json # Navigation configuration ├── project-cfd.svg # Project-level cumulative flow diagram ├── sprints/ │ ├── _category_.json # Sprint section navigation │ ├── sprint1.md # Individual sprint reports with: │ ├── sprint2.md # - Backlog tables │ └── charts/ # - Dependency analysis │ ├── cfd-sprint1.svg # - Gantt charts │ ├── throughput-sprint1.svg # - Forecast analysis │ └── cfd-sprint2.svg # - Charts and metrics └── data/ └── db/ ├── project.json # Project metadata ├── issue.json # All issues with hierarchy and dependencies ├── backlog.json # Backlog structures ├── timebox.json # Sprint data with items and assignments ├── roadmap.json # Roadmap with milestones and releases ├── team.json # Team and member information └── process.json # Process definitions   ","version":"Next","tagName":"h3"},{"title":"Data Flow Mapping​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#data-flow-mapping","content":" ","version":"Next","tagName":"h2"},{"title":"1. AST → Domain Models​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#1-ast--domain-models","content":" // From parsed .made file Model → { Project, Team[], Backlog[], TimeBox[], Roadmap[] }   ","version":"Next","tagName":"h3"},{"title":"2. Domain Models → Output Artifacts​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#2-domain-models--output-artifacts","content":" Project → { &quot;01_overview.md&quot;, // Project metrics and forecast &quot;project-cfd.svg&quot;, // Project-level cumulative flow &quot;data/db/project.json&quot; } Backlog[] → { &quot;02_backlogs.md&quot;, // Backlog documentation (may be minimal) &quot;data/db/backlog.json&quot;, // Structured backlog data &quot;data/db/issue.json&quot; // Issues with dependencies } TimeBox[] → { &quot;sprints/{sprint-name}.md&quot;, // Individual sprint reports with analysis &quot;charts/cfd-{sprint}.svg&quot;, // Sprint cumulative flow diagrams &quot;charts/throughput-{sprint}.svg&quot;, // Sprint throughput charts &quot;data/db/timebox.json&quot; // Sprint data with assignments } Roadmap[] → { &quot;03_roadmap.md&quot;, // Roadmap with milestones and timeline &quot;data/db/roadmap.json&quot; // Structured roadmap data } Team[] → { &quot;data/db/team.json&quot; // Team and member data } Process[] → { &quot;data/db/process.json&quot; // Process definitions }   ","version":"Next","tagName":"h3"},{"title":"3. GitHub Push Mapping​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#3-github-push-mapping","content":" Project → GitHub Project V2 Issue[] → GitHub Issues TimeBox[] → GitHub Milestones Team[] → GitHub Teams (optional)   ","version":"Next","tagName":"h3"},{"title":"Customization Points​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#customization-points","content":" ","version":"Next","tagName":"h2"},{"title":"Custom Chart Types​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#custom-chart-types","content":" // Add new chart generator class CustomChartGenerator { generate(data: BacklogData): string { // Return SVG or Mermaid content } }   ","version":"Next","tagName":"h3"},{"title":"Custom Documentation Sections​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#custom-documentation-sections","content":" // Add new markdown service class CustomMarkdownService { generateCustomSection(data: ProjectData): string { // Return markdown content } }   ","version":"Next","tagName":"h3"},{"title":"Custom GitHub Integration​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#custom-github-integration","content":" // Extend GitHub push service class CustomGitHubPushService extends GitHubPushService { async pushCustomArtifacts(data: CustomData): Promise&lt;void&gt; { // Custom GitHub integration logic } }   ","version":"Next","tagName":"h3"},{"title":"Template System​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#template-system","content":" ","version":"Next","tagName":"h2"},{"title":"Markdown Templates​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#markdown-templates","content":" Templates use Handlebars-like syntax for dynamic content:  # {{project.name}} **Description:** {{project.description}} **Duration:** {{project.startDate}} to {{project.dueDate}} ## Team Members {{#each teams}} ### {{name}} {{#each teamMembers}} - **{{name}}** ({{email}}) {{/each}} {{/each}}   ","version":"Next","tagName":"h3"},{"title":"Chart Templates​","type":1,"pageTitle":"Artifact Map","url":"/leds-tools-public/made/advanced-topics/made_artifact_map#chart-templates","content":" SVG charts use data-driven generation:  const chartData = { title: sprint.name, data: sprintItems.map(item =&gt; ({ date: item.completedDate, remaining: calculateRemaining(item) })) }; const svg = generateBurndownChart(chartData);   This artifact mapping provides a comprehensive view of how MADE transforms input definitions into various output formats, enabling both documentation and project management workflows. ","version":"Next","tagName":"h3"},{"title":"How to Use MADE CLI","type":0,"sectionRef":"#","url":"/leds-tools-public/made/how_to_use/made_cli_usage","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Global Installation​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#global-installation","content":" npm install -g made-beta   ","version":"Next","tagName":"h3"},{"title":"Local Usage (without installation)​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#local-usage-without-installation","content":" npx made-beta --help   ","version":"Next","tagName":"h3"},{"title":"Prerequisites​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#prerequisites","content":" Node.js installed on your system  ","version":"Next","tagName":"h2"},{"title":"Commands​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#commands","content":" ","version":"Next","tagName":"h2"},{"title":"Help​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#help","content":" Get help information at any time:  made-cli --help   ","version":"Next","tagName":"h3"},{"title":"Generate Documentation​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#generate-documentation","content":" Generate markdown documentation from your .made file:  made-cli generate project.made   Options:  -d, --destination &lt;dir&gt; - Specify destination directory  Example:  made-cli generate myproject.made -d ./docs   ","version":"Next","tagName":"h3"},{"title":"GitHub Integration​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#github-integration","content":" Push your project structure to GitHub:  made-cli github project.made   ","version":"Next","tagName":"h3"},{"title":"GitHub Setup​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#github-setup","content":" ","version":"Next","tagName":"h2"},{"title":"1. Create Environment File​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#1-create-environment-file","content":" Create a .env file in the same directory as your .made file:  GITHUB_TOKEN=your_github_personal_access_token GITHUB_ORG=your_organization_or_username GITHUB_REPO=your_repository_name   ","version":"Next","tagName":"h3"},{"title":"2. GitHub Token Setup​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#2-github-token-setup","content":" Go to GitHub Settings &gt; Developer settings &gt; Personal access tokensGenerate a new token with these permissions: repo - Full repository accesswrite:org - Create teams and manage organization Copy the token to your .env file  ","version":"Next","tagName":"h3"},{"title":"3. Execute Command​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#3-execute-command","content":" made-cli github myproject.made   ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Basic Documentation Generation​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#basic-documentation-generation","content":" # Generate docs in current directory made-cli generate project.made # Generate docs in specific directory made-cli generate project.made -d ./documentation   ","version":"Next","tagName":"h3"},{"title":"GitHub Integration Workflow​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#github-integration-workflow","content":" # 1. Ensure .env is configured cat .env # GITHUB_TOKEN=ghp_xxxxxxxxxxxx # GITHUB_ORG=myorg # GITHUB_REPO=myrepo # 2. Push to GitHub made-cli github project.made   ","version":"Next","tagName":"h3"},{"title":"Output​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#output","content":" ","version":"Next","tagName":"h2"},{"title":"Documentation Generation​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#documentation-generation","content":" Creates markdown files for backlogs, sprints, roadmapsGenerates charts and dependency diagramsProduces team and project documentation  ","version":"Next","tagName":"h3"},{"title":"GitHub Push​","type":1,"pageTitle":"How to Use MADE CLI","url":"/leds-tools-public/made/how_to_use/made_cli_usage#github-push","content":" Creates GitHub Issues for Epics, Stories, and TasksSets up GitHub Projects with proper structureCreates milestones and assigns team membersLinks dependencies between issues ","version":"Next","tagName":"h3"},{"title":"Grammar Tokens","type":0,"sectionRef":"#","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens","content":"","keywords":"","version":"Next"},{"title":"Grammar Structure​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#grammar-structure","content":" ","version":"Next","tagName":"h2"},{"title":"Main Grammar Entry Point​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#main-grammar-entry-point","content":" grammar Made import 'helpers' import 'terminals' import 'projects' import 'backlog' import 'processes' import 'timebox' import 'team' import 'roadmap' entry Model: (project=Project) (components+=(Team|Process|Backlog|TimeBox|Roadmap))*   ","version":"Next","tagName":"h3"},{"title":"Core Tokens​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#core-tokens","content":" ","version":"Next","tagName":"h2"},{"title":"1. Project Definition​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#1-project-definition","content":" Project: 'project' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('startDate:' startDate=DATE)? ('dueDate:' dueDate=DATE)? ('completedDate:' completedDate=DATE)? '}';   ","version":"Next","tagName":"h3"},{"title":"2. Team Structure​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#2-team-structure","content":" Team: 'team' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? (teammember+=TeamMember)* '}'; TeamMember: 'teammember' id=ID '{' 'name:' name=STRING 'email:' email=STRING ('discord:' discord=STRING)? '}';   ","version":"Next","tagName":"h3"},{"title":"3. Process Definition​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#3-process-definition","content":" Process: 'process' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? (activities+=Activity)* '}'; Activity: 'activity' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('DefinitionDone:' definitionDone=STRING)? ('DefinitionReady:' definitionReady=STRING)? ('Learning:' learning=STRING)? ('Label:' label=ID)? (tasks+=TaskProcess)* '}';   ","version":"Next","tagName":"h3"},{"title":"4. Backlog Structure​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#4-backlog-structure","content":" Backlog: 'backlog' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? (items+=BacklogItem)* '}'; Epic: 'epic' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('process:' process=[Process:QualifiedName])? ('Criterions:' criterions=StringList)? ('observation:' observation=STRING)? (userstories+=UserStory)* '}'; UserStory: 'story' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('activity:' activity=[Activity:QualifiedName])? ('depends:' depends=ReferenceList)? ('Requirements:' requirements=StringList)? ('Criterions:' criterions=StringList)? ('observation:' observation=STRING)? (tasks+=Task)* '}'; Task: 'task' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('task:' taskRef=[TaskProcess:QualifiedName])? ('depends:' depends=ReferenceList)? ('Deliverables:' deliverables=StringList)? '}';   ","version":"Next","tagName":"h3"},{"title":"5. TimeBox (Sprint) Definition​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#5-timebox-sprint-definition","content":" TimeBox: 'sprint' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('startDate:' startDate=DATE)? ('endDate:' endDate=DATE)? ('status:' status=SprintStatus)? ('comment:' comment=STRING)? ('completeDate:' completeDate=DATE)? (sprintbacklog+=SprintBacklog)* '}'; SprintBacklog: 'sprintbacklog' id=ID '{' (items+=SprintItem)* '}'; SprintItem: 'item' reference=[BacklogItem:QualifiedName] '{' ('assignee:' assignee=[TeamMember:QualifiedName])? ('dueDate:' dueDate=DATE)? ('startDate:' startDate=DATE)? ('completedDate:' completedDate=DATE)? ('status:' status=ItemStatus)? ('complexity:' complexity=Complexity)? '}';   ","version":"Next","tagName":"h3"},{"title":"6. Roadmap Structure​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#6-roadmap-structure","content":" Roadmap: 'roadmap' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? (milestones+=Milestone)* '}'; Milestone: 'milestone' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('startDate:' startDate=DATE)? ('dueDate:' dueDate=DATE)? ('completedDate:' completedDate=DATE)? ('status:' status=MilestoneStatus)? ('depends:' depends=[Milestone:QualifiedName])? (releases+=Release)* '}'; Release: 'release' id=ID '{' ('name:' name=STRING)? ('description:' description=STRING)? ('version:' version=STRING)? ('dueDate:' dueDate=DATE)? ('releasedDate:' releasedDate=DATE)? ('status:' status=ReleaseStatus)? (('item:' item=[BacklogItem:QualifiedName]) | ('itens:' items=ReferenceList))? '}';   ","version":"Next","tagName":"h3"},{"title":"Terminal Definitions​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#terminal-definitions","content":" ","version":"Next","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#basic-types","content":" terminal ID: /[_a-zA-Z][\\w_]*/; terminal STRING: /&quot;[^&quot;]*&quot;/; terminal DATE: /\\d{4}-\\d{2}-\\d{2}/; terminal INT returns number: /[0-9]+/;   ","version":"Next","tagName":"h3"},{"title":"Enumerations​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#enumerations","content":" enum SprintStatus: PLANNED | IN_PROGRESS | CLOSED; enum ItemStatus: TODO | DOING | DONE; enum Complexity: LOW | MEDIUM | HIGH; enum MilestoneStatus: PLANNED | IN_PROGRESS | COMPLETED | CANCELLED; enum ReleaseStatus: PLANNED | IN_DEVELOPMENT | RELEASED | CANCELLED;   ","version":"Next","tagName":"h3"},{"title":"Helper Types​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#helper-types","content":" StringList: values+=STRING (',' values+=STRING)*; ReferenceList: references+=[BacklogItem:QualifiedName] (',' references+=[BacklogItem:QualifiedName])*; QualifiedName: ID ('.' ID)*;   ","version":"Next","tagName":"h3"},{"title":"Advanced Grammar Features​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#advanced-grammar-features","content":" ","version":"Next","tagName":"h2"},{"title":"Cross-References​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#cross-references","content":" // Reference to team member 'assignee:' assignee=[TeamMember:QualifiedName] // Reference to process activity 'activity:' activity=[Activity:QualifiedName] // Reference to other backlog items for dependencies 'depends:' depends=ReferenceList   ","version":"Next","tagName":"h3"},{"title":"Optional Properties​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#optional-properties","content":" // Optional description field ('description:' description=STRING)? // Optional date fields ('startDate:' startDate=DATE)? ('dueDate:' dueDate=DATE)?   ","version":"Next","tagName":"h3"},{"title":"Collections​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#collections","content":" // Multiple team members (teammember+=TeamMember)* // Multiple tasks in user story (tasks+=Task)* // Multiple items in sprint backlog (items+=SprintItem)*   ","version":"Next","tagName":"h3"},{"title":"Validation Rules​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#validation-rules","content":" ","version":"Next","tagName":"h2"},{"title":"Date Format Validation​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#date-format-validation","content":" export function validateDates(node: any, accept: any) { const typeMeta = reflection.getTypeMetaData(node.$type); for (const prop of typeMeta.properties) { if (prop.name.match(/date$/i) &amp;&amp; typeof node[prop.name] === 'string') { const value = node[prop.name]; if (value &amp;&amp; !/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) { accept('error', `Property &quot;${prop.name}&quot; must be in ISO 8601 format (YYYY-MM-DD)`, { node, property: prop.name }); } } } }   ","version":"Next","tagName":"h3"},{"title":"Reference Validation​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#reference-validation","content":" Cross-references are validated at parse timeScoped resolution ensures correct reference targetsDependency cycles are detected and reported  ","version":"Next","tagName":"h3"},{"title":"Grammar Extension Points​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#grammar-extension-points","content":" ","version":"Next","tagName":"h2"},{"title":"Adding New Component Types​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#adding-new-component-types","content":" // Add to main grammar entry Model: (project=Project) (components+=(Team|Process|Backlog|TimeBox|Roadmap|CustomComponent))*; // Define new component CustomComponent: 'custom' id=ID '{' 'property:' property=STRING // ... additional properties '}';   ","version":"Next","tagName":"h3"},{"title":"Adding New Properties​","type":1,"pageTitle":"Grammar Tokens","url":"/leds-tools-public/made/advanced-topics/made_grammar_tokens#adding-new-properties","content":" // Extend existing components Task: 'task' id=ID '{' 'name:' name=STRING ('description:' description=STRING)? ('priority:' priority=Priority)? // New property // ... existing properties '}';   This grammar structure provides a solid foundation for the MADE DSL while maintaining flexibility for extensions and customizations. ","version":"Next","tagName":"h3"},{"title":"How to Use MADE in VS Code","type":0,"sectionRef":"#","url":"/leds-tools-public/made/how_to_use/made_vscode_usage","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Method 1: VS Code Marketplace​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#method-1-vs-code-marketplace","content":" Open Visual Studio CodeGo to Extensions (Ctrl+Shift+X)Search for &quot;MADE - Leds - Beta&quot;Click Install  ","version":"Next","tagName":"h3"},{"title":"Method 2: Direct Install Link​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#method-2-direct-install-link","content":" Click to Install  ","version":"Next","tagName":"h3"},{"title":"Method 3: Manual Installation (VSIX)​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#method-3-manual-installation-vsix","content":" Download the latest .vsix file from releasesOpen Visual Studio CodeRight-click and select &quot;Install Extension VSIX&quot;  ","version":"Next","tagName":"h3"},{"title":"Basic Usage​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#basic-usage","content":" ","version":"Next","tagName":"h2"},{"title":"1. Create a .made File​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#1-create-a-made-file","content":" Create a new file with the .made extension in your project directory.  ","version":"Next","tagName":"h3"},{"title":"2. Generate Documentation​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#2-generate-documentation","content":" Right-click on your .made fileSelect Generate DocumentationMarkdown files will be generated in the same directory    ","version":"Next","tagName":"h3"},{"title":"3. GitHub Integration Setup​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#3-github-integration-setup","content":" Create a .env file in the same directory as your .made file:  GITHUB_TOKEN=your_github_token GITHUB_ORG=your_organization GITHUB_REPO=your_repository   ","version":"Next","tagName":"h3"},{"title":"4. Push to GitHub​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#4-push-to-github","content":" Right-click on your .made fileSelect Generate Github IssuesIssues and project structure will be created in GitHub    ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#features","content":" Syntax Highlighting: Full syntax support for .made filesAuto-completion: IntelliSense for MADE DSLError Detection: Real-time validation and error reportingRight-click Actions: Easy access to generation commandsEnvironment Integration: Automatic .env file detection  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#troubleshooting","content":" ","version":"Next","tagName":"h2"},{"title":"Common Issues​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#common-issues","content":" Missing .env file: Ensure GitHub credentials are properly configuredPermission errors: Verify GitHub token has necessary permissionsSyntax errors: Check the .made file for proper DSL syntax  ","version":"Next","tagName":"h3"},{"title":"Required GitHub Token Permissions​","type":1,"pageTitle":"How to Use MADE in VS Code","url":"/leds-tools-public/made/how_to_use/made_vscode_usage#required-github-token-permissions","content":" repo - Full repository accesswrite:org - Create teams and manage organization ","version":"Next","tagName":"h3"},{"title":"MADE Example Files","type":0,"sectionRef":"#","url":"/leds-tools-public/made/how_to_use/made_examples","content":"","keywords":"","version":"Next"},{"title":"Basic Project Structure​","type":1,"pageTitle":"MADE Example Files","url":"/leds-tools-public/made/how_to_use/made_examples#basic-project-structure","content":" project myproject { name: &quot;My Awesome Project&quot; description: &quot;A sample project to demonstrate MADE features&quot; startDate: 2024-01-01 dueDate: 2024-12-31 } team developers { name: &quot;Development Team&quot; description: &quot;Core development team&quot; teammember john { name: &quot;John Doe&quot; email: &quot;john@company.com&quot; discord: &quot;johndoe&quot; } teammember jane { name: &quot;Jane Smith&quot; email: &quot;jane@company.com&quot; discord: &quot;janesmith&quot; } }   ","version":"Next","tagName":"h2"},{"title":"Process Definition​","type":1,"pageTitle":"MADE Example Files","url":"/leds-tools-public/made/how_to_use/made_examples#process-definition","content":" process webdevelopment { name: &quot;Web Development Process&quot; description: &quot;Standard web development workflow&quot; activity planning { name: &quot;Planning Phase&quot; description: &quot;Project planning and requirements gathering&quot; task requirements { name: &quot;Gather Requirements&quot; description: &quot;Document functional and non-functional requirements&quot; } task architecture { name: &quot;Design Architecture&quot; description: &quot;Design system architecture and tech stack&quot; depends: webdevelopment.planning.requirements } } activity development { name: &quot;Development Phase&quot; description: &quot;Implementation and testing&quot; task coding { name: &quot;Code Implementation&quot; description: &quot;Implement features according to specifications&quot; } } }   ","version":"Next","tagName":"h2"},{"title":"Backlog with Epic and Stories​","type":1,"pageTitle":"MADE Example Files","url":"/leds-tools-public/made/how_to_use/made_examples#backlog-with-epic-and-stories","content":" backlog productbacklog { name: &quot;Product Backlog&quot; description: &quot;Main product features and requirements&quot; epic authentication { name: &quot;User Authentication System&quot; description: &quot;Implement secure user authentication&quot; process: webdevelopment Criterions: &quot;Support multiple auth methods&quot;, &quot;Secure password handling&quot; observation: &quot;Consider OAuth integration&quot; story login { name: &quot;User Login&quot; description: &quot;Basic username/password login functionality&quot; activity: webdevelopment.planning Requirements: &quot;Email validation&quot;, &quot;Password strength checking&quot; Criterions: &quot;Successful login redirects to dashboard&quot; task loginform { name: &quot;Create Login Form&quot; description: &quot;HTML form with validation&quot; task: webdevelopment.development.coding Deliverables: &quot;Login form component&quot;, &quot;Form validation&quot; } task authentication { name: &quot;Backend Authentication&quot; description: &quot;Server-side authentication logic&quot; depends: productbacklog.authentication.login.loginform Deliverables: &quot;Auth API endpoints&quot;, &quot;Session management&quot; } } story registration { name: &quot;User Registration&quot; description: &quot;New user account creation&quot; task regform { name: &quot;Registration Form&quot; description: &quot;User registration form with validation&quot; Deliverables: &quot;Registration form&quot;, &quot;Email verification&quot; } } } }   ","version":"Next","tagName":"h2"},{"title":"Sprint Planning​","type":1,"pageTitle":"MADE Example Files","url":"/leds-tools-public/made/how_to_use/made_examples#sprint-planning","content":" sprint sprint1 { name: &quot;Sprint 1 - Authentication&quot; description: &quot;Implement basic authentication features&quot; startDate: 2024-02-01 endDate: 2024-02-14 status: IN_PROGRESS sprintbacklog items { item productbacklog.authentication.login.loginform { assignee: developers.john dueDate: 2024-02-07 status: TODO complexity: MEDIUM } item productbacklog.authentication.login.authentication { assignee: developers.jane dueDate: 2024-02-12 status: TODO complexity: HIGH } item productbacklog.authentication.registration.regform { assignee: developers.john dueDate: 2024-02-14 status: TODO complexity: LOW } } }   ","version":"Next","tagName":"h2"},{"title":"Roadmap with Milestones​","type":1,"pageTitle":"MADE Example Files","url":"/leds-tools-public/made/how_to_use/made_examples#roadmap-with-milestones","content":" roadmap projectroadmap { name: &quot;Project Roadmap 2024&quot; description: &quot;Strategic development plan for the year&quot; milestone v1 { name: &quot;Version 1.0 - MVP&quot; description: &quot;Minimum viable product with core features&quot; startDate: 2024-01-01 dueDate: 2024-06-30 status: IN_PROGRESS release alpha { name: &quot;Alpha Release&quot; description: &quot;Initial feature set for testing&quot; version: &quot;0.1.0&quot; dueDate: 2024-03-31 status: IN_DEVELOPMENT item: productbacklog.authentication } release beta { name: &quot;Beta Release&quot; description: &quot;Feature-complete beta version&quot; version: &quot;0.9.0&quot; dueDate: 2024-06-15 status: PLANNED itens: productbacklog.authentication.login, productbacklog.authentication.registration } } }   ","version":"Next","tagName":"h2"},{"title":"Complete Example File​","type":1,"pageTitle":"MADE Example Files","url":"/leds-tools-public/made/how_to_use/made_examples#complete-example-file","content":" // Download complete example: example.made   This example demonstrates:  Project setup with team membersReusable process definitionBacklog with dependenciesSprint planning with assignmentsRoadmap with milestones and releasesProper dependency management between tasks ","version":"Next","tagName":"h2"},{"title":"What is MADE","type":0,"sectionRef":"#","url":"/leds-tools-public/made/made_overview","content":"","keywords":"","version":"Next"},{"title":"Key Features​","type":1,"pageTitle":"What is MADE","url":"/leds-tools-public/made/made_overview#key-features","content":" Process Reuse: Define processes once, reuse across projectsStandardization: Consistent project management across teamsGitHub Integration: Push directly to GitHub Issues and ProjectsDocumentation Generation: Auto-generate markdown reportsAgile Support: Built-in support for Epics, Stories, Tasks, and Sprints  ","version":"Next","tagName":"h2"},{"title":"Core Components​","type":1,"pageTitle":"What is MADE","url":"/leds-tools-public/made/made_overview#core-components","content":" MADE uses a Domain-Specific Language (DSL) that consists of:  Project: Configuration and metadataTeam: Team members and organizationBacklog: Epics, Stories, and TasksTimeBox: Sprints and iterationsProcess: Reusable workflowsRoadmap: Milestones and releases  ","version":"Next","tagName":"h2"},{"title":"How It Works​","type":1,"pageTitle":"What is MADE","url":"/leds-tools-public/made/made_overview#how-it-works","content":" Write your project structure in .made files using the DSLUse VS Code extension or CLI to process the filesGenerate documentation or push to GitHub automaticallyMaintain consistency across projects with reusable processes  ","version":"Next","tagName":"h2"},{"title":"Benefits​","type":1,"pageTitle":"What is MADE","url":"/leds-tools-public/made/made_overview#benefits","content":" Consistency: Standardized approach to project managementEfficiency: Reduce repetitive setup workIntegration: Seamless GitHub workflow integrationDocumentation: Auto-generated, always up-to-date documentationCollaboration: Clear team structure and responsibility definition ","version":"Next","tagName":"h2"},{"title":"Metrics","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/","content":"Metrics This page documents the key metrics used to monitor and improve our project performance. Each metric includes a definition, purpose, calculation method, how will we measure it, and the impact it'll have in the project. We also provide a website that dynamically updates the graphs of these metrics using real-time data fetched from our GitHub projects. This ensures that our visualizations always reflect the most up-to-date project status: Live Metrics Dashboard Access our dynamic dashboard with real-time metrics from GitHub: 📊 Open the live site 🔁 Throughput Measure the number of work items (like features or bug fixes) completed per unit of time. It helps answer, &quot;How much work are we getting done?&quot; 📈 BurnUp Track your team's progress against the total project scope. This chart clearly shows work completed, total scope, and the expected completion date. ⏱️ Lead Time Understand the total time elapsed from the moment a work item is requested until it is delivered. It reflects the entire customer experience. 🔄 Cycle Time Focus on the active development time. This measures the time from when work begins on an item until it is ready for delivery. It answers, &quot;How long does it take to do the work?&quot;","keywords":"","version":"Next"},{"title":"How to use","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/how_to_use","content":"","keywords":"","version":"Next"},{"title":"How to connect to AWS​","type":1,"pageTitle":"How to use","url":"/leds-tools-public/oraculo/how_to_use#how-to-connect-to-aws","content":" You can watch our video tutorial clicking here  ","version":"Next","tagName":"h2"},{"title":"Some commands that will be used to configure the AWS machine​","type":1,"pageTitle":"How to use","url":"/leds-tools-public/oraculo/how_to_use#some-commands-that-will-be-used-to-configure-the-aws-machine","content":" ","version":"Next","tagName":"h2"},{"title":"Generating SSH Key​","type":1,"pageTitle":"How to use","url":"/leds-tools-public/oraculo/how_to_use#generating-ssh-key","content":" ssh-keygen   cat ~/.ssh/id_rsa.pub   ","version":"Next","tagName":"h3"},{"title":"Setting up Docker​","type":1,"pageTitle":"How to use","url":"/leds-tools-public/oraculo/how_to_use#setting-up-docker","content":" sudo apt-get update   sudo apt-get install ca-certificates curl gnupg   sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg   echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release &amp;&amp; echo $VERSION_CODENAME) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null   sudo apt-get update   sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin   sudo groupadd docker   sudo usermod -aG docker $USER   newgrp docker  ","version":"Next","tagName":"h3"},{"title":"Architecture and Modularization","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/architecture","content":"","keywords":"","version":"Next"},{"title":"Main Components​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#main-components","content":" 🔁 Airbyte (ETL) Responsible for extracting data from GitHub (issues, pull requests, etc.), transforming and loading it into the PostgreSQL database. The current approach captures data from Airbyte's temporary cache, transforms it, and inserts it into a custom relational schema with normalized tables. This improves compatibility with Vanna and enables more accurate SQL generation. ⚙️ Backend (FastAPI) API developed with FastAPI. It acts as a bridge between the user and the database: receives questions, uses the AI to generate SQL queries, executes them, and formats the responses. Pattern used: MVC (Model, View, Controller) 🧠 MyVanna (LLM/AI) AI component that uses Google's Gemini model and ChromaDB. It interprets user questions, generates SQL, runs queries, and translates responses into natural language. Responsibilities: Understands the database schemaGenerates and runs SQL queriesLearns from custom examples Additionally, to validate AI responses, the system now includes semantic similarity tests using Google BERT. These tests compare the generated SQL with expected queries using cosine similarity. If similarity is below 60%, the response is flagged as poor quality. 🌐 OpenWebUI (Graphical Interface) The visual interface where the user interacts with the system, submits questions, and receives responses.  ","version":"Next","tagName":"h2"},{"title":"Overview of the Data Flow​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#overview-of-the-data-flow","content":" User (OpenWebUI interface) ↓ pipeline_api.py ↓ FastAPI (backend/API) ↓ Vanna.AI (LLM) ↓ SQL → PostgreSQL Database ↓ ↪ Response shown to the user  ","version":"Next","tagName":"h2"},{"title":"Architecture Summary by Role​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#architecture-summary-by-role","content":" Component\tRole\tDescriptionOpenWebUI\tInterface\tFrontend for user interaction FastAPI (API)\tBackend/API\tReceives questions, uses AI, queries database Airbyte\tETL\tExtracts GitHub data and loads it into PostgreSQL MyVanna\tLLM / AI\tGenerates SQL and natural language responses using Gemini + Chroma PostgreSQL\tDatabase\tStores GitHub data queried by the system  ","version":"Next","tagName":"h2"},{"title":"Design Patterns Used​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#design-patterns-used","content":" Singleton Ensures only one instance of key components like: AskController (question logic)MyVanna (AI client)airbyte (ETL process) MVC (Model-View-Controller) Applied in the API: Models: Define the structure of questions/responsesControllers: Process the logic (e.g. AskController.py)Views/Routes: Handle API endpoints (e.g. routes.py)  ","version":"Next","tagName":"h2"},{"title":"Deployment​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#deployment","content":" The entire system is containerized using Docker. Components defined in docker-compose.yml include:  db: PostgreSQL databaseback-end: Python-based API and ETLfront-end: OpenWebUI interface  Configuration files include Dockerfile.dev, Dockerfile.pub, and Dockerfile.  ","version":"Next","tagName":"h2"},{"title":"Security and Configuration​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#security-and-configuration","content":" Sensitive data is stored in .env files. This includes:  GitHub tokenDatabase passwordGemini API key  ","version":"Next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#testing","content":" Tests are implemented using pytest, including:  MyVanna tests (SQL generation and DB connection)Pipeline tests (question handling)API tests (/ask endpoint)AI Response Quality Tests: Implemented with BERT to evaluate the semantic similarity between expected and generated SQL queries. Tests fail if similarity drops below 60%.    The Oráculo system demonstrates how AI and GitHub integration can simplify development tracking through natural language. Its architecture is modular, follows good design principles, and is production-ready with testing, containerization, and secure configuration. ","version":"Next","tagName":"h2"},{"title":"BurnUp","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/burnup","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-definition","content":" A visual tool that shows the amount of work completed over time compared to the total work planned.  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-purpose","content":" To track progress toward a goal, visualize scope changes, and understand if the team is on track to meet deadlines.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-calculation-method","content":" X-axis: Time (e.g., sprints or days)Y-axis: Work items (e.g., number of issues or story points)Plot two lines: Completed work line: Cumulative count of completed items.Total work line: Constant or adjusted if scope changes.  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure in the project?​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-how-will-we-measure-in-the-project","content":" We will use data from GitHub Projects for measurement, monitoring the number of open and closed issues over time. Thus, the Burnup chart will be built based on the accumulation of closed issues in relation to the total planned for each sprint.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-project-impact","content":" The Burnup allows us to compare the flow of incoming issues in the project with their resolution, evaluating the development team's ability to complete tasks within the expected timeframe. From this metric, it's possible to estimate a satisfactory volume of new issues to be defined in a sprint and to identify deviations such as delays or an increase in tasks. ","version":"Next","tagName":"h3"},{"title":"Cycle Time","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/cycletime","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-definition","content":" The time taken to actively work on a task, from the moment work starts until it is completed.  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-purpose","content":" To analyze how long the team takes to process tasks once they begin working on them, helping to optimize internal workflow.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-calculation-method","content":" Subtract the task start date (when work begins) from the completion date.  Formula: Cycle Time = Completion date - Start of work date  🔎 Note: Cycle Time is always ≤ Lead Time.  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure in the project?​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-how-will-we-measure-in-the-project","content":" The measurement will be based on data from GitHub Projects, calculating the time it takes from the start of work on an issue to its completion (closure). This time covers the active development phase, without considering periods of waiting or inactivity. The analysis will be continuous, and the results will be reviewed at the end of each sprint to identify variations in development time.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-project-impact","content":" Cycle time is an essential metric for evaluating the efficiency of the development process. By monitoring it, the team can identify where delays are occurring in the workflow and adjust processes to reduce cycle time. This results in faster deliveries and helps increase the team’s ability to handle more tasks simultaneously, optimizing the overall project performance. ","version":"Next","tagName":"h3"},{"title":"Lead Time","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/leadtime","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-definition","content":" The total time taken from the moment a task is requested (created) to the moment it is completed (delivered).  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-purpose","content":" To evaluate the end-to-end efficiency of the process and understand how long stakeholders wait for a feature or task.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-calculation-method","content":" Subtract the task creation date from the completion date.  Formula: Lead Time = Completion date - Creation date  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure in the project?​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-how-will-we-measure-in-the-project","content":" Measurement will be based on data from GitHub Projects, considering the total time between the opening of an issue and its closure. This time represents the full work cycle for each item. Monitoring will be continuous, and the data will be analyzed at the end of each sprint, making it possible to evaluate the average delivery time for demands.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-project-impact","content":" Lead time provides a clear view of the delivery process's agility. By tracking this metric, it becomes possible to identify delays, understand where bottlenecks occur, and improve delivery predictability. This strengthens commitment to deadlines, increases transparency with stakeholders, and supports decision-making to optimize the team’s workflow. ","version":"Next","tagName":"h3"},{"title":"Throughput","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/throughput","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-definition","content":" The number of work items (e.g., issues, tasks, user stories) completed within a given time frame (usually a sprint or week).  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-purpose","content":" To measure the productivity of the team by tracking how many tasks are delivered over time.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-calculation-method","content":" Count the number of completed items during a specific time period.  Formula: Throughput = Number of items completed / Time period  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure it in the project?​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-how-will-we-measure-it-in-the-project","content":" Measurement will be based on data from GitHub Projects, counting the number of completed (closed) issues in each sprint. Monitoring will be continuous, and the results will be consolidated at the end of each development cycle, allowing us to identify the actual delivery volume of the team.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-project-impact","content":" Throughput provides a clear view of the team’s productivity, helping to determine the ideal amount of work per sprint. By tracking this metric, it is possible to identify performance trends, adjust team capacity, and detect workflow bottlenecks. This directly contributes to more accurate planning and continuous improvement of project processes. ","version":"Next","tagName":"h3"},{"title":"🧙 Oráculo: Team wisdom in real time","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/overview","content":"","keywords":"","version":"Next"},{"title":"1️⃣ Git Integration​","type":1,"pageTitle":"🧙 Oráculo: Team wisdom in real time","url":"/leds-tools-public/oraculo/overview#1️⃣-git-integration","content":" Connected to the team's repository, the Oráculo answers key questions about development progress:  What tasks are pending for team X or product Y?Which sprint tasks are still open for product Y?  🧭 Use these questions to:  Identify bottlenecksGet insights on a specific feature in developmentTrack what’s still openSpeed up planning meetings  ✅ The answers are always based on the latest state of the repositories and team boards.    ℹ️ Transparency, context, and agility. The Oráculo exists to turn raw data into better decisions. ","version":"Next","tagName":"h2"},{"title":"Suggestions for Improvements","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/suggestions_improvements","content":"","keywords":"","version":"Next"},{"title":"Suggestion 1: Conversation Memory in AI​","type":1,"pageTitle":"Suggestions for Improvements","url":"/leds-tools-public/oraculo/suggestions_improvements#suggestion-1-conversation-memory-in-ai","content":" Concept​  Add contextual memory to the chatbot, allowing it to keep track of previous user interactions. This way, sequential questions can be understood within the same context, without requiring repetition.  Why implement?​  Currently, each question to Oráculo is processed in isolation, forcing users to repeat context for each query. With memory, it would be possible to maintain a continuous dialogue, improving usability and making interactions more natural.  Benefits​  Enables chained queries (e.g., “Which tasks are open?” → “And from those, which belong to the current sprint?”).Reduces redundancy and saves user time.Makes the chatbot behave more like an intelligent personal assistant.    ","version":"Next","tagName":"h3"},{"title":"Suggestion 2: Graph Generation and Standardized Responses​","type":1,"pageTitle":"Suggestions for Improvements","url":"/leds-tools-public/oraculo/suggestions_improvements#suggestion-2-graph-generation-and-standardized-responses","content":" Concept​  Enable Oráculo to generate visual charts (bar, line, pie) from GitHub metrics, and apply a standard response format for all answers.  Why implement?​  Currently, the system only provides plain text responses, which can make it harder to interpret complex metrics. Visual outputs make results easier to understand and more useful for sprint reviews or team meetings. Standardized responses ensure that information is always presented consistently, supporting comparison and professional reporting.  Benefits​  Improves clarity of communication (e.g., sprint performance, number of open/closed issues).Easier analysis for managers who prefer visuals over text.Creates a more professional experience aligned with modern management tools.    ","version":"Next","tagName":"h3"},{"title":"Suggestion 3: Dynamic Token Management​","type":1,"pageTitle":"Suggestions for Improvements","url":"/leds-tools-public/oraculo/suggestions_improvements#suggestion-3-dynamic-token-management","content":" Concept​  Allow updating API tokens (e.g., GitHub, Gemini) directly through the system interface, without editing the .env file or restarting services.  Why implement?​  Currently, token replacement requires manual changes to the .env file and restarting the application. This process creates friction, especially for non-technical users, and interrupts workflow. With dynamic token management, users could update credentials in real time, ensuring better usability and flexibility.  Benefits​  Fast replacement of expired credentials.Reduces technical dependency by avoiding manual file editing. ","version":"Next","tagName":"h3"},{"title":"📌 Project Development Plan","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/project_managment","content":"","keywords":"","version":"Next"},{"title":"📋 Backlog​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-backlog","content":" ID\tTeam\tFeature\tDescription\tImportance\tProposal1\tManagement\tMetric Results\tCollect, analyze, and document project metrics throughout development.\t100\tImprove performance tracking 2\tDevelopers\tDynamic Data Import\tUser inserting more repostories's data with the system running.\t90\tImprove user experience 3\tDevelopers\tLLM Memory Implementation\tImplement context in the conversation with the LLM.\t70\tImprove user chat experience 4\tDevelopers\tCentralized Data and Access Control\tDifferent repositories in one place with access control mapping to users.\t95\tImprove setup configuration and ensure data security 5\tDevelopers\tLLM Answers Generating Graphical Data\tDeliver graphic information through the LLM chat.\t80\tImprove LLM answers    ","version":"Next","tagName":"h2"},{"title":"🧩 Project Model Canvas​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-project-model-canvas","content":" ","version":"Next","tagName":"h2"},{"title":"🔍 Justifications​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-justifications","content":" Ease github data visualization via LLM chat.    ","version":"Next","tagName":"h3"},{"title":"🎯 Product​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-product","content":" Oráculo improvement.    ","version":"Next","tagName":"h3"},{"title":"🧠 SMART Goal​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-smart-goal","content":" Improve Oráculo overall usability and chat experience in up to 4 months with 3 managers and 3 developers.    ","version":"Next","tagName":"h3"},{"title":"✅ Requirements​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-requirements","content":" User must be able to add repositories through a screen;LLM should have memory, for context storage;User acess must be restricted to their respective repositories;    ","version":"Next","tagName":"h3"},{"title":"🎁 Benefits​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-benefits","content":" Flexibility in importing data from multiple repositories while running;Time optimization when analyzing project progress.    ","version":"Next","tagName":"h3"},{"title":"👥 External Stakeholders & Factors​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-external-stakeholders--factors","content":" Advisors, scholarship holders, staff, and other stakeholders involved in LEDS and FAPES.    ","version":"Next","tagName":"h3"},{"title":"🔮 Assumptions​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-assumptions","content":" There will be access to AWS servers;Use of Open-source dependencies.Improvements implemented in 4 months.    ","version":"Next","tagName":"h3"},{"title":"⚠️ Risks​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#️-risks","content":" 1. Lack of technical capacity of the developers​  Probability: 70%Mitigation: Rething the delivery deadlines.  2. Project complexity being increased by Paulo Sergio​  Probability: 50%  3. Withdrawal of team members​  Probability: 20%  4. Unaccessible dependencies​  Probability: 5%Mitigation: Search and study replacement dependencies.    ","version":"Next","tagName":"h3"},{"title":"👥 Team​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-team","content":" 🧭 Management:​  Lívia Hombre (Steadiness);Pedro Henrique Fonseca (Steadiness);Thiago Fabiano (Dominance);Felipe Trindade.  🛠️ Developers:​  Alicia Caporalli (Steadiness);Sofia Nascimento;Vivian Lacerda.    ","version":"Next","tagName":"h3"},{"title":"🧱 Team Topology​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-team-topology","content":" Platform Team Enables stream-aligned teams to deliver work autonomously. While stream-aligned teams maintain full ownership of their work, the platform team provides internal services and tools to support delivery.    ","version":"Next","tagName":"h3"},{"title":"📦 Deliverables​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-deliverables","content":" Management:​  Results with collected metrics  Developers:​  Dynamic Data Import;LLM Memory Implementation;Centralized Data and Access Control;LLM Answers Generating Graphical Data.    ","version":"Next","tagName":"h3"},{"title":"⛓ Constraints​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-constraints","content":" Delivery deadline: 4 months.    ","version":"Next","tagName":"h3"},{"title":"🗓 Timeline​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-timeline","content":" First delivery: 31/08Second delivery: 28/09Third delivery: 02/11Fourth delivery: 30/11    ","version":"Next","tagName":"h3"},{"title":"💰 Costs​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-costs","content":" Developer Cost: R$1,000.00 × 7 members = R$7,000.00AWS Hosting Cost (4 months): R$ 5.0 × 120 days × 7 members= R$4,200.00Gemini API Cost: R$12.00 × 120 days × 7 members = R$10,080.00  Total: R$21,280.00​   ","version":"Next","tagName":"h3"},{"title":"Guide Map","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/anchor","content":"","keywords":"","version":"Next"},{"title":"I Want to Use Spark​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#i-want-to-use-spark","content":" ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#prerequisites","content":" To use Spark, you must know System Analysis, at least class modeling. You can also see the following links:  Internet Text Content: Free Online Course; Books: Systems Analysis and Design (Howard Gould); Portuguese Content: Apostila de Análise de Sistemas;  To understand the Spark-generated architecture, you will need different content for each one...  For MVC-Based Architectures:  Internet Text Content: For Django MVC;For Spring Boot; Portuguese Content: O que é MVC;  For Clean Architecture-Based Architectures:  Book: Clean Architecture: A Craftsman's Guide to Software Structure and Design (Robert Martin); Portuguese Content: Clean Architecture com o Macoratti;  For Minimal API-Based Architectures:  Video Content: Learn Minimal API in C# .NET; Portuguese Content: Aprendendo a Minimal API em C# .NET;  About the frontend: it will generate a LEDS internal architecture, so it will be properly explained in section Vue Plus Vuetify.  If you want to understand what REST APIs are, you can also check:  PhD Thesis: Architectural Styles and the Design of Network-based Software Architectures; Internet Text Content: An Introduction to REST APIs.  ","version":"Next","tagName":"h3"},{"title":"Suggested Route​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#suggested-route","content":" See Overview to understand the Spark principles and objectives;See Installation to install and use Spark;See Writing a File to learn how to write your first &quot;.spark&quot;; andSee File Examples to see example files.  ","version":"Next","tagName":"h3"},{"title":"For Advanced Users​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#for-advanced-users","content":" See Understanding the Generated Code Architecture to understand the generated code architecture; For Clean Architecture C#, see Clean Architecture Csharp;For MVC Django Rest Framework Architecture in Python, see Python Architecture;For Minimal API C#, see Minimal API Csharp; andFor MVC Spring-Boot Architecture in Java, see Java Architecture.  ","version":"Next","tagName":"h3"},{"title":"I Want to Improve the Spark Code​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#i-want-to-improve-the-spark-code","content":" When dealing with Spark, you must know that there are two different source codes. The first is about the grammar specifier, called Spark, and the compiler, called SparkLib. To improve the code, you need to integrate both of them.  ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#prerequisites-1","content":" Here we will specify each major knowledge area you will need to know to improve the code. In each area, there are too many references. You don’t need to get all of them, just choose the ones that work best for you.  For Theoretical Principles, you will need to know about:  Automata Theory: Internet Text Content: Wikipedia, a Great Start;State Machines Reference;Chomsky Hierarchy; Books: Introduction to Automata Theory, Languages, and Computation, third edition (John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman); Video Content: A Complete Introduction to Computation Theory; Portuguese Content: Linguagens Formais e Autômatos, playlist;Linguagens Formais e Autômatos, fifth edition (Paulo Blauth Menezes);Apostila, Linguagens Formais e Autômatos; Domain-Specific Languages (DSL): Internet Text Content: Wikipedia, a Great Start;State Machines Reference; Articles and Papers: Ontology-Driven Development of Domain-Specific Languages; The Abstract Syntax Tree (AST) data structure: Wikipedia, a Great Start;Another Simple Explanation.  In the Technical Area, you will need:  Langium: Internet Text Content: Lib Reference; Object-Oriented Programming: Internet Content: Wikipedia, a Great Start;Advanced Content with Refactoring Guru; Video Content: What is OOP; Portuguese Content: Um bom começo com a Alura;Curso de POO do Gustavo Guanabara; TypeScript: Internet Text Content: Official Documentation;Official Handbook; Video Content: Learn TypeScript in 1 Hour; Portuguese Content: Cursinho de TypeScript.  ","version":"Next","tagName":"h3"},{"title":"Suggested Route​","type":1,"pageTitle":"Guide Map","url":"/leds-tools-public/spark/anchor#suggested-route-1","content":" See An Advanced Study to understand the grammar tokens and their uses;See Metamodel to check the grammar metamodel;See Architecture to check the Spark source code architecture;See Library Architecture - Backend to check the library backend scoped architecture;See Library Architecture - Frontend to check the library frontend scoped architecture; ","version":"Next","tagName":"h3"},{"title":"First Steps","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/how_to_use/","content":"","keywords":"","version":"Next"},{"title":"Pre-Requisits:​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#pre-requisits","content":" Installed VSCode (any version; dubh).  ","version":"Next","tagName":"h2"},{"title":"Instalation​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#instalation","content":" Open Visual Studio Code;Click on Extensions;Search for &quot;Spark&quot;;Click to install the Spark extension by LEDS IFES; andHave Fun :)  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#features","content":" An integrated gramma validation to .spark files; andSimple access to Backend, Frontend and Project Documentation generation module.  ","version":"Next","tagName":"h2"},{"title":"How to Use​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#how-to-use","content":" Create a .spark file (e.g. my_spark_file.spark);Fill it with your class, packages and specific some project configuration and save it;Click with right mouse button (os api button 2); andSelect option you want (or generate all, or generate backend, or generate frontend or generate documentation).  Using it CLI in Node  ","version":"Next","tagName":"h2"},{"title":"Pre-Requisits​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#pre-requisits-1","content":" Have an good os (no, Windows is not a god os, use WSL instead);NodeJs (recoomend 20.x or better) installed in your machine; andNPM installed in your machine.  ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#installation","content":" On bash use the following comand: npx install spark-leds-beta.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#features-1","content":" Access only to all generation module mode.  ","version":"Next","tagName":"h2"},{"title":"How to Use​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#how-to-use-1","content":" On installed folder (where packages.json are) use the command npx spark-cli generate path/to/.spark/file.  ","version":"Next","tagName":"h2"},{"title":"Output​","type":1,"pageTitle":"First Steps","url":"/leds-tools-public/spark/how_to_use/#output","content":" A folder named &quot;frontend&quot; with the frontend generated;A folder named &quot;backend&quot; with the backend generated; andA folder named &quot;docs&quot; with the documentation files.  Output Hierarchy Examples   ","version":"Next","tagName":"h2"},{"title":"Oráculo","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/minimundo","content":"","keywords":"","version":"Next"},{"title":"Context​","type":1,"pageTitle":"Oráculo","url":"/leds-tools-public/oraculo/minimundo#context","content":" In software development teams, project information is often spread across GitHub repositories, where tasks, issues, and pull requests are managed. Analyzing this data manually is time-consuming and makes it difficult to obtain a clear and real-time view of the project’s progress. This causes problems such as:  Difficulty in identifying pending tasks and bottlenecks.Lack of agility in tracking team performance.Limited visibility for managers and advisors to support decision-making.  The Oráculo system was created to address these challenges by using AI to transform raw GitHub data into natural language answers.    ","version":"Next","tagName":"h2"},{"title":"Target System​","type":1,"pageTitle":"Oráculo","url":"/leds-tools-public/oraculo/minimundo#target-system","content":" Tool: Oráculo (Chatbot System).Main functions to be validated: Extract and organize data from GitHub repositories.Allow queries in natural language about project status.Provide clear insights into sprint progress and team performance.Ensure transparency and agility in project management.    ","version":"Next","tagName":"h2"},{"title":"Objectives​","type":1,"pageTitle":"Oráculo","url":"/leds-tools-public/oraculo/minimundo#objectives","content":" Provide a real-time view of project progress.Support managers in decision-making.Facilitate performance tracking of teams and individuals.    ","version":"Next","tagName":"h2"},{"title":"Rules and Restrictions​","type":1,"pageTitle":"Oráculo","url":"/leds-tools-public/oraculo/minimundo#rules-and-restrictions","content":" Must extract data from GitHub repositories.Queries must be answered through natural language processing (NLP).Data must be stored and structured in a PostgreSQL database.System must ensure transparency and reliability in the information provided. ","version":"Next","tagName":"h2"},{"title":".spark File","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/how_to_use/file_examples/moranguinho","content":"In free translate, Litle Strawbery .spark File Configuration { software_name: &quot;Morango&quot; about: &quot;Moranguinho!&quot; language: csharp-clean-architecture } module Moranguinho { entity Agricultor{ nome: string identification: cpf email_x: email telefone: string foto: file Agricultor OneToMany Moranguinho.Propriedade } entity Propriedade { nome: string distrito: string } } Class Diagram Output","keywords":"","version":"Next"},{"title":"Running Locally and Debugging","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/how_to_use/run_and_debug","content":"","keywords":"","version":"Next"},{"title":"Repository and branch​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#repository-and-branch","content":" All steps in this guide are intended to be run inside the LEDs Tools Spark repository on the developing branch:  Repository: https://github.com/leds-org/leds-tools-spark/tree/developing  Clone and check out the correct branch:  git clone https://github.com/leds-org/leds-tools-spark.git cd leds-tools-spark git fetch --all git checkout developing   Then run the following steps from the repository root.  ","version":"Next","tagName":"h2"},{"title":"1. Install Dependencies​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#1-install-dependencies","content":" Install the project dependencies defined in package.json.  npm i   Note: npm i is a shortcut for npm install.  ","version":"Next","tagName":"h2"},{"title":"2. Generate Code from Grammar​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#2-generate-code-from-grammar","content":" Translate your language's grammar (for example, a .langium file) into executable TypeScript. This generates the parser and core language server components.  npm run langium:generate   ","version":"Next","tagName":"h2"},{"title":"3. Compile the Project​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#3-compile-the-project","content":" Compile the entire TypeScript project (generated files + your custom code) into JavaScript so the extension can run.  npm run build   ","version":"Next","tagName":"h2"},{"title":"4. Launch the Development Environment​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#4-launch-the-development-environment","content":" Start a special VS Code instance with your extension loaded.  Press F5  This opens a new window named &quot;Extension Development Host&quot; where your extension is active for testing.  ","version":"Next","tagName":"h2"},{"title":"5. Test Language Features​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#5-test-language-features","content":" In the new VS Code window:  Create a new file using your language's file extension ( example.spark).Start writing code and verify that features work as expected: Syntax Highlighting: keywords, strings, and comments are colored correctly.Validation: errors and warnings are underlined in the editor.Code Completion: suggestions appear as you type (if implemented).  ","version":"Next","tagName":"h2"},{"title":"6. Use the Command-Line Interface (CLI)​","type":1,"pageTitle":"Running Locally and Debugging","url":"/leds-tools-public/spark/how_to_use/run_and_debug#6-use-the-command-line-interface-cli","content":" The project includes a CLI to interact with your language outside VS Code (useful for code generation and batch processing).  Show available options:  node ./bin/cli   Generate code from a specific DSL file:  node ./bin/cli generate &lt;file&gt;   Example:  node ./bin/cli generate src/example.spark     Tips  If you're on Windows PowerShell, the above npm and node commands work the same.If generation or build fails, re-run step 2 (grammar generation) before building to ensure generated sources are up to date.Use the &quot;Developer: Toggle Developer Tools&quot; command in the Extension Development Host to inspect runtime logs. ","version":"Next","tagName":"h2"},{"title":".spark File","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/how_to_use/file_examples/conecta_fapes","content":"","keywords":"","version":"Next"},{"title":"Generated Documentation​","type":1,"pageTitle":".spark File","url":"/leds-tools-public/spark/how_to_use/file_examples/conecta_fapes#generated-documentation","content":"   ","version":"Next","tagName":"h2"},{"title":"Generated Backend​","type":1,"pageTitle":".spark File","url":"/leds-tools-public/spark/how_to_use/file_examples/conecta_fapes#generated-backend","content":"   ","version":"Next","tagName":"h2"},{"title":"Generated Frontend​","type":1,"pageTitle":".spark File","url":"/leds-tools-public/spark/how_to_use/file_examples/conecta_fapes#generated-frontend","content":"  ","version":"Next","tagName":"h2"},{"title":"A Brief About Grammar","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/how_to_use/advanced_study","content":"","keywords":"","version":"Next"},{"title":"Token Mapper​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#token-mapper","content":" Keyword\tCategory\tQualifier\tExamplesConfiguration\tName Space software_name\tSingle Item\tstring\tsoftware_name: &quot;free text&quot; about\tSingle Item\tstring\tabout: &quot;free text&quot; language\tSingle Item\tenum\tlanguage: csharp-clean-architecture  Attention: every &quot;string&quot; qualifier must be inside quotation marks (&quot;)  ","version":"Next","tagName":"h2"},{"title":"Language Token Mapper​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#language-token-mapper","content":" Enum Option\tDescriptioncsharp-clean-architecture\tspecificer the backend must be generated using .NET with Clean Architecture Architecture csharp-minimal-api\tspecificer the backend must be generated using .NET with Minimal API Architecture python\tspecifier the backend must be generated using Django rest framework with DJango MVC Architecture java\tspecifier the backend must be generated using SpringBoot with SpringBoot MVC Architecture  ","version":"Next","tagName":"h3"},{"title":"Setting Configuration​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#setting-configuration","content":" To start the section namespace include the keyword Configuration and start it block. Internal, it must have:  software_name (single item with string qualifier);about (single item with string qualifier); andlanguage (single item with enum qualifier).  Configuration Example   Configuration { software_name: &quot;name_of_the_software&quot; about: &quot;software description&quot; language: csharp-clean-architecture-custom }   The language token accept the keys specified here.  The Module NameSpace  This namespace refers to Domain Class Packages and/or program Packages/Modules. The module key word to refers to it was arbitrary chosed.  ","version":"Next","tagName":"h2"},{"title":"Token Mapper​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#token-mapper-1","content":" Keyword\tCategory\tName\tAcceptable Sub Name Spaces\tCorrect Examples\tWrong Examplesmodule\tName Space\tfree text with no special characters, inclunding numbers, &quot;\\&quot; based chars in ASCII and utf-8, and spaces.\tmodule, entity and enum\tmodule someName, module SomeName, module SOMENAME_NAME_WHY_YOU_IS_DOING_it\tmodule 1Name, module Module Name, module &lt;keyword&gt; entity\tName Space\tfree text with no special characters, inclunding numbers, &quot;\\&quot; based chars in ASCII and utf-8, and spaces\tenum\tentity someName, entity SomeName, entity SOMENAME_NAME_WHY_YOU_IS_DOING_it\tentity 1Name, entity Entity Name, entity &lt;keyword&gt; enum\tName Space\tfree text with no special characters, inclunding numbers, &quot;\\&quot; based chars in ASCII and utf-8, and spaces enum someName, enum SomeName, enum some_NaMe\tenum 1Name, enum Enum Name, enum &lt;keyword&gt;  ","version":"Next","tagName":"h2"},{"title":"Setting Module​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#setting-module","content":" Start insert the keyword module, set some module name and initialize the namespace block. Then, insert in it other modules, entitys or both. It must have at least one module or entity.  Module Example 1  module ModuleName { module SubModule {...} }   Module Example 2  entity EntityName {...}   Module Example 3  // some description comment module ModuleName { module SubModule {...} entity SomeEntity {...} }   Wrong Module Example  module ModuleName { // empty module :( }   The Class NameSpace  The class namespace have an diferent internal struct. Each item in it is an attribute... Check it out.  ","version":"Next","tagName":"h2"},{"title":"The Attribute Item​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#the-attribute-item","content":" The ttribute have the follow semantic:attributeName : &lt;qualifier&gt;  The most important qualifier are types, and it must be the first specified qualifier. After it, you could use to many other qualifiers, like blank, null, etc.  ","version":"Next","tagName":"h2"},{"title":"Attribute Qualifiers - Types Enum​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#attribute-qualifiers---types-enum","content":" Token\tDescriptionstring\trefers to strings attribute in referenced language integer\trefers to integers attribute in referenced language decimal\trefers to precising decimal representation attribute in referenced language (it could not be float or double) datetime\trefers to date and time attribute in referenced language date\trefers to date attribute in referenced language boolean\trefers to boolean attribute in referenced language uuid\trefers to Universal User Identfier attribute wich depends the tecnology implemented (example, in C# it use UUID class from .NET) email\trefers to email attribute wich depends the tecnology implemented (example, in Python it use EmailField class from Django) cpf\trefers to &quot;Cadastro de Pessoa Física&quot; attribute wich depends the tecnology implemented (example, in Python it use CPFField class from django-cpf-cnpj) [Specific for Brazil] cnpj\trefers to &quot;Cadastro Nacional de Pessoa Jurídica&quot; attribute wich depends the tecnology implemented (example, in Python it use CNPJField class from django-cpf-cnpj) [Specific for Brazil] currency\trefers to monetary manipulation attribute wich depends the tecnology implemented mobilePhoneNumber\trefers to mobile phones number attribute wich depends the tecnology implemented phoneNumber\trefers to landline phones number attribute wich depends the tecnology implemented  ","version":"Next","tagName":"h3"},{"title":"Attribute Qualifiers - Otehrs Enum​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#attribute-qualifiers---otehrs-enum","content":" Token\tDescriptionunique\trefers to unique attributes; some types, like uuid, it are implict blank\trefers to attributes could be blank null\trefers to attributes could be null min\twe don't know how use it, but it is here :) max\twe don't know how use it, but it is here :)  About blank and null​  Some databases technologys, like PostegressSQL and MySQL, diferes null attributes from blank attributes. The most part of REST API frameworks abrating the database technology, so this qualifiers will be passed to it. In other hand, some languages, like javascript, difers undefined from null objects, so the blank modifier will be interpreter as undefined and null will be interpreted as null.  About min and max attributes​  Yes, we don't know why it is here, but have rules to use. First, you can use each of them separatly. Next, you must pass some integer value affter the qualifier declaration, like min: 10. In end, if you use min and max together, you must specify the max first.  ","version":"Next","tagName":"h3"},{"title":"The Relations Items​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#the-relations-items","content":" To specify some relations between classes you will need the ManyToOne, OneToMany, OneToOne and ManyToMany keywords. Everyone work's at same. First, set some class reference (it can be from other module to). Next, set some keyword. In the end, specify the other side of relation.  Attention, the relation are seted in the referenced order, not referenced class. Check it example:  entity One {...} entity Two { one ManyToOne Two }   The code above will be translated in some generic OO Program Language Like  class One { Two target; } class Two { }   It is useful in analysis to center the order of viewing. Here's the example: You have a class diagram with the Product and Price classes. It is obvious that the product has some relationship with the price of the class. Correct? So how do you specify it in Spark?   entity Product {...} entity Price { OneToOne Product Price }    entity Price {...}   Both are correctly and probably do exactly the same thing in each implementation. By the way, check the first option. It's less intuitive at first glance, but the reasoning here is obvious that a product has some price, so we'll show it after, where it could be more useful than knowing (where we're studying the Product class).  ","version":"Next","tagName":"h2"},{"title":"The Enum NameSpace​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#the-enum-namespace","content":" The enum namepace are some of most simples to specify. Just start the enum namepace with enum keyword. Aftter, each free text inside will be option in the enum. To set some class attribute as an enum reference file, use the keyword uses.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"A Brief About Grammar","url":"/leds-tools-public/spark/how_to_use/advanced_study#examples","content":" Classes (with attributes and relations)  // Module Desscription module ModuleName { // entity Description entity ClassName { // attribute description attributeName : attributeType ClassName OneToOne ModuleName.AnotherClass } entity AnotherClass { attribute : attributeType enumReference uses MyEnum ClassName ManyToOne AnotherClass } enum MyEnum { op1 op2 op3 } }  ","version":"Next","tagName":"h2"},{"title":"What is Spark?","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/overview","content":"","keywords":"","version":"Next"},{"title":"Generated Artifacts​","type":1,"pageTitle":"What is Spark?","url":"/leds-tools-public/spark/overview#generated-artifacts","content":" Backend: a pseudo REST API integrated with the SWAGGER tool in the following technologies (to be selected): Django Rest Framework + Python, in the Model View Controller architecture;Spring Boot + Java, in the Model View Controller architecture;.NET + C#, in the Minimal API and Clean Architecture architectures (to be selected). Frontend: a pseudo frontend integrated with the Backend using the technologies Node.js + Vue + Tailwind; with Vite as a testing dependency.  In addition, it also generates domain class diagrams using PlantUML along with texts in Markdown and CI/CD structures in GitLab.  ","version":"Next","tagName":"h2"},{"title":"Core Components​","type":1,"pageTitle":"What is Spark?","url":"/leds-tools-public/spark/overview#core-components","content":" Spark uses a Domain-Specific Language (DSL) that consists of:  Configuration: Configuration and metadata;Package: Package Definition;Etity: Class Definition;enum: Enum Classes Definition; andtypes: Defines types for classes attributes.  ","version":"Next","tagName":"h2"},{"title":"How It Works​","type":1,"pageTitle":"What is Spark?","url":"/leds-tools-public/spark/overview#how-it-works","content":" Write your project structure in .spark files using the DSL; andUse VS Code extension or CLI to process the files.  ","version":"Next","tagName":"h2"},{"title":"Benefits​","type":1,"pageTitle":"What is Spark?","url":"/leds-tools-public/spark/overview#benefits","content":" Quicker start on big software projects; andPadronized code structure for backend and frontend code. ","version":"Next","tagName":"h2"},{"title":"Suggestion of Next Features","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/future/nextfeatures","content":"","keywords":"","version":"Next"},{"title":"Task 1: Generate Standard Descriptions for Functions​","type":1,"pageTitle":"Suggestion of Next Features","url":"/leds-tools-public/spark/project_managment/future/nextfeatures#task-1-generate-standard-descriptions-for-functions","content":" Objective: Improve the quality and documentation of the generated code. The task consists of making SparkLib automatically add documentation comments (XML-docs for C#, Javadoc for Java, etc.) to all CRUD functions it creates.  Example (C#):  /// &lt;summary&gt; /// Creates a new instance of 'Product'. /// &lt;/summary&gt; /// &lt;param name=&quot;productDto&quot;&gt;The data object to create the Product.&lt;/param&gt; /// &lt;returns&gt;The newly created Product.&lt;/returns&gt; public async Task&lt;Product&gt; Create(ProductDTO productDto) { // ... generated code }   Suggested Action Plan:  Locate the CRUD Method Generators: Go to the generator folder you're working with (e.g., src/backend/csharp-generator/cleanArchitecture-generator/).Find the files responsible for each CRUD operation. For example, in Application/UseCase/Case/, you'll probably find files like CreateCase/generate.ts, UpdateCase/generate.ts, etc. Create Comment Templates: Within each of these files, before generating the method code, create a template string for the comment block.Use information from the entity's AST node and method to dynamically fill the template. Inject the Comment into the Final Code: Connect the generated comment block with the function code and return the complete string.  Tip: Create a helper function in src/util/generator-utils.ts to generate these comment blocks, avoiding code duplication.    ","version":"Next","tagName":"h3"},{"title":"Task 2: Generate Unit Tests for CRUD​","type":1,"pageTitle":"Suggestion of Next Features","url":"/leds-tools-public/spark/project_managment/future/nextfeatures#task-2-generate-unit-tests-for-crud","content":" Objective: Make SparkLib generate basic unit tests for CRUD Use Cases or Services. Since CRUD functions don't have complex business rules, their tests are quite standardized and ideal for automation.  Suggested Action Plan:  Investigate the Test Structure: Look for folders like DomainTest or InfraTest within the C# generators (e.g., src/backend/csharp-generator/cleanArchitecture-generator/DomainTest/). Analyze the modeltest-generator.ts file. It should already give clues about how test generation is structured. The goal is to create something similar for Use Cases. Create a New Test Generator for Use Cases: Create a new folder and file structure to generate tests for the Application/Use Cases layer. For each generated UseCase (e.g., CreateProductUseCase), you should generate a corresponding test class (e.g., CreateProductUseCaseTests). Implement Test Generation Logic: Arrange: Generate code that creates mocks for dependency interfaces (mainly IRepository). Create an instance of the Use Case being tested, injecting the mocks. Act: Generate the call to the method being tested (e.g., _useCase.Handle(request, CancellationToken.None)). Assert: Generate assertions. For a Create test, you can verify that the repository's AddAsync method was called once. For GetById, verify that the result is not null. ","version":"Next","tagName":"h3"},{"title":"Release Plan","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/future/release-plan","content":"","keywords":"","version":"Next"},{"title":"Version 1 for .NET​","type":1,"pageTitle":"Release Plan","url":"/leds-tools-public/spark/project_managment/future/release-plan#version-1-for-net","content":" Estimated duration: 2 WeeksExpected delivery date: End of AugustFeatures: Tracing and Logging in .NET; Implement automated back-end tests + basic CRUD; Implement automated front-end tests + basic CRUD; Modifications suggested by the DEV team;  ","version":"Next","tagName":"h2"},{"title":"Version 2​","type":1,"pageTitle":"Release Plan","url":"/leds-tools-public/spark/project_managment/future/release-plan#version-2","content":" Estimated duration: 4 WeeksExpected delivery date: SeptemberFeatures: Generation of authorization rules with OPA  ","version":"Next","tagName":"h2"},{"title":"Version 3​","type":1,"pageTitle":"Release Plan","url":"/leds-tools-public/spark/project_managment/future/release-plan#version-3","content":" Estimated duration: 3 WeeksExpected delivery date: OctoberFeatures: Using AI Pipeline for inserting; Business Rules into domain classes (2 weeks); Inserting new attributes into existing classes (1 week);  ","version":"Next","tagName":"h2"},{"title":"Language Hierarchy","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/how_to_use/writting_a_file","content":"","keywords":"","version":"Next"},{"title":"The Attribute Item​","type":1,"pageTitle":"Language Hierarchy","url":"/leds-tools-public/spark/how_to_use/writting_a_file#the-attribute-item","content":" The attribute have the follow semantic:attributeName : &lt;qualifier&gt;  The most important qualifier are types, and it must be the first specified qualifier. After it, you could use to many other qualifiers, like blank, null, etc.  ","version":"Next","tagName":"h2"},{"title":"Attribute Qualifiers - Types Enum​","type":1,"pageTitle":"Language Hierarchy","url":"/leds-tools-public/spark/how_to_use/writting_a_file#attribute-qualifiers---types-enum","content":" Token\tDescriptionstring\trefers to strings attribute in referenced language integer\trefers to integers attribute in referenced language decimal\trefers to precising decimal representation attribute in referenced language (it could not be float or double) datetime\trefers to date and time attribute in referenced language date\trefers to date attribute in referenced language boolean\trefers to boolean attribute in referenced language uuid\trefers to Universal User Identfier attribute wich depends the tecnology implemented (example, in C# it use UUID class from .NET) email\trefers to email attribute wich depends the tecnology implemented (example, in Python it use EmailField class from Django) cpf\trefers to &quot;Cadastro de Pessoa Física&quot; attribute wich depends the tecnology implemented (example, in Python it use CPFField class from django-cpf-cnpj) [Specific for Brazil] cnpj\trefers to &quot;Cadastro Nacional de Pessoa Jurídica&quot; attribute wich depends the tecnology implemented (example, in Python it use CNPJField class from django-cpf-cnpj) [Specific for Brazil] currency\trefers to monetary manipulation attribute wich depends the tecnology implemented mobilePhoneNumber\trefers to mobile phones number attribute wich depends the tecnology implemented phoneNumber\trefers to landline phones number attribute wich depends the tecnology implemented  ","version":"Next","tagName":"h3"},{"title":"Attribute Qualifiers - Otehrs Enum​","type":1,"pageTitle":"Language Hierarchy","url":"/leds-tools-public/spark/how_to_use/writting_a_file#attribute-qualifiers---otehrs-enum","content":" Token\tDescriptionunique\trefers to unique attributes; some types, like uuid, it are implict blank\trefers to attributes could be blank null\trefers to attributes could be null  About blank and null​  Some databases technologys, like PostegressSQL and MySQL, diferes null attributes from blank attributes. The most part of REST API frameworks abrating the database technology, so this qualifiers will be passed to it. In other hand, some languages, like javascript, difers undefined from null objects, so the blank modifier will be interpreter as undefined and null will be interpreted as null.  ","version":"Next","tagName":"h3"},{"title":"The Relations Items​","type":1,"pageTitle":"Language Hierarchy","url":"/leds-tools-public/spark/how_to_use/writting_a_file#the-relations-items","content":" To specify some relations between classes you will need the ManyToOne, OneToMany, OneToOne and ManyToMany keywords. Everyone work's at same. First, set some class reference (it can be from other module to). Next, set some keyword. In the end, specify the other side of relation.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Language Hierarchy","url":"/leds-tools-public/spark/how_to_use/writting_a_file#examples","content":" Classes (with attributes and relations)  // Module Desscription module ModuleName { // entity Description entity ClassName { // attribute description attributeName : attributeType ClassName OneToOne ModuleName.AnotherClass } entity AnotherClass { attribute : attributeType enumReference uses MyEnum ClassName ManyToOne AnotherClass } enum MyEnum { op1 op2 op3 } }  ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/overview","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/spark/project_managment/overview#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tCreate authorization service rules based on Actor and User Case's Events\tCreate authorization rules on Back-End and Front-End based on relations among actors and User Case's Events\t100\tImprove software development process by 10% 2\tCreate authorization data rules based on Actor and User Case's Events\tCreate authorization data rules on Back-End and Front-End based on relations among actors and User Case's Events (Owner Patterns)\t95\tImprove software development process by 10% 3\tImplement Minimal API with M(domain, service)VC pattern\tApply M(domain, service)VC pattern using Minimal API approach in C#, Java, and Django projects\t90\tStandardize architecture to reduce rework 4\tFix document insertion error in Django\tIdentify and fix the issue preventing document insertion in Django\t85\tEnsure system integrity and functionality 5\tAdd missing library in Java project\tIdentify and integrate the required library to ensure proper execution of the Java project\t80\tEliminate technical blockers for the team 6\tFix general errors in Django\tResolve various backend issues in the Django project\t88\tReduce bugs and improve system stability 7\tGenerate classes based on use case type\tAutomate the creation (or not) of classes based on the use case type (e.g., CRUD or non-CRUD)\t82\tBoost productivity in software modeling 8\tGenerate code with AI based on use case comments\tUse AI to analyze comments and automatically generate supporting code\t93\tAccelerate development with intelligent assistance  ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/spark/project_managment/overview#general-planning","content":" Stopped development on creating OPA based on actor and use case events, without a link to C#.  Release 1.0 (14/10/2024 - 01/11/2024): Create authorization service rules based on Actor and User Case's Events on C# application and Create authorization data rules based on Actor and User Case`s Events (Owner Patterns) on C#  ","version":"Next","tagName":"h2"},{"title":"Release 1.0 - 01/11/2024​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/spark/project_managment/overview#release-10---01112024","content":" Goal: Create authorization service and data based on User Case Diagram Features: ID 1 and ID 2 Deadline I - 25/10/2024 ID 1: Create authorization service rules based on Actor and User Case's Events on C# application Deadline II - 01/11/2024 ID 2: Create authorization data rules based on Actor and User Case`s Events (Owner Patterns) on C#  ","version":"Next","tagName":"h2"},{"title":"🗂️ Comunication Plan – SPARK (Frontend)","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan","content":"","keywords":"","version":"Next"},{"title":"1. Main Goal​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan#1-main-goal","content":" Ensure clear, efficient, and continuous communication among the members of the Software Project Management, Systems Project teams, and stakeholders, promoting alignment, progress tracking, and identification of obstacles.    ","version":"Next","tagName":"h2"},{"title":"2. Participants​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan#2-participants","content":" Name\tRole\tLevel of EngagementLarissa Rangel\tGPS Team Leader\tMuito Alto Gabriel Barbosa\tProject Planner and Facilitator\tMuito alto Lorhan de Souza\tSupport Team Member\tMédio Thiago Carvalho\tSupport Team Member\tMédio Rodolfo\tSupport Team Member\tBaixo Bruno da Fonseca Chevitarese\tPS Team Leader\tMuito Alto Henrique de Souza Lima\tSupport Team Member\tMédio Guilherme Borges Cabral\tSupport Team Member\tMuito Alto Nicolas Duarte Botelho\tSupport Team Member\tMuito Alto Lucas Bruno Alves\tSupport Team Member\tBaixo    ","version":"Next","tagName":"h2"},{"title":"3. Comunication Channels​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan#3-comunication-channels","content":" Type of Comunication\tChannel\tGoal\tParticipants\tFrequencyFast Comunication\tDiscord\tIssue resolution and quick notifications\tGPS and PS Teams\tEvery day Sprint Planning\tGoogle Meet + Github Projects + PMC\tTasks Planning\tGPS Team\tWeekly Weekly\tGoogle Meet\tShare status and obstacles\tGPS and PS Teams\tWeekly    ","version":"Next","tagName":"h2"},{"title":"4. Comunication Routine​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan#4-comunication-routine","content":" Event\tFormat\tDuration\tFrequency\tFacilitator\tNotesReview and Planning\tOnline Meeting\t30 min\tWeekly\tLeader GPS Team\tUses PMC and Github Projects to review the previous steps and plan the next ones Weekly\tOnline Meeting\t45 min\tWeekly\tLeaders GPS and PS Team\tOne of the members of the Systems Project Team answer the questions about the Ongoing Project    ","version":"Next","tagName":"h2"},{"title":"5. Responsables for Comunication​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan#5-responsables-for-comunication","content":" Content Type\tLead ResponsableTechnical Status\tPS Team Planning and Backlog\tGPS Team Meeting Facilitator\tFacilitator Comunication with stakeholders\tGPS and PS Team Leaders Technical Documentation\tSupport Team Members    ","version":"Next","tagName":"h2"},{"title":"6. Good Practices​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/frontend_communication_plan#6-good-practices","content":" Use asynchronous communication whenever possible.Avoid long or unfocused meetings.Keep all documents updated and accessible.Maintain ongoing comunication through Discord channels for each Team.Encourage frequent feedback. ","version":"Next","tagName":"h2"},{"title":"🗂️ Comunication Plan – SPARK (Frontend)","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan","content":"","keywords":"","version":"Next"},{"title":"1. Main Goal​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan#1-main-goal","content":" Ensure clear, efficient, and continuous communication among the members of the Software Project Management, Systems Project teams, and stakeholders, promoting alignment, progress tracking, and identification of obstacles.    ","version":"Next","tagName":"h2"},{"title":"2. Participants​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan#2-participants","content":" Name\tRole\tLevel of EngagementJoão Vitor Lopes\tGPS Team Leader\tHigh João Victor Vieira\tGPS Team Member\tHigh João Pedro Pagotto\tGPS Team Member\tHigh Alex Rossoni\tGPS Team Member\tHigh Davi Breda\tGPS Team Member\tHigh Thalison Vinícius\tGPS Team Member\tHigh Murilo Dias de Oliveira\tProject Development Team Leader\tHigh Lucas Gabriel Araújo\tProject Development Team Member\tHigh Bruno Alves\tProject Development Team Member\tHigh Arthur Valentim\tProject Development Team Member\tHigh Caio chiabai de Oliveira\tProject Development Team Member\tHigh Diego Bourguignon\tProject Development Team Member\tHigh    ","version":"Next","tagName":"h2"},{"title":"3. Comunication Channels​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan#3-comunication-channels","content":" Type of Comunication\tChannel\tGoal\tParticipants\tFrequencyFast Comunication\tDiscord + Whatsapp\tIssue resolution and quick notifications + direct communication between dev and manager\tGPS and PS Teams\tEvery day Sprint Planning\tGoogle Meet or In Person + Github Projects + PMC\tTasks Planning\tGPS Team\tWeekly Weekly\tGoogle Meet or In Person\tShare status and obstacles\tGPS and PS Teams\tWeekly    ","version":"Next","tagName":"h2"},{"title":"4. Comunication Routine​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan#4-comunication-routine","content":" Event\tFormat\tDuration\tFrequency\tFacilitator\tNotesReview and Planning\tOnline Meeting or In Person\t15-30 min\tWeekly\tLeader GPS Team\tUses PMC and Github Projects to review the previous steps and plan the next ones Weekly\tOnline Meeting or In Person\t45 min - 1 hour\tWeekly\tLeaders GPS and PS Team\tOne of the members of the Project Development Team answers the questions about the Ongoing Project, and lists impediments and issues that may arise    ","version":"Next","tagName":"h2"},{"title":"5. Responsables for Comunication​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan#5-responsables-for-comunication","content":" Content Type\tLead ResponsableTechnical Status\tPS Team Planning and Backlog\tGPS Team Meeting Facilitator\tFacilitator Comunication with stakeholders\tGPS and PS Team Leaders Technical Documentation\tProject Development Team    ","version":"Next","tagName":"h2"},{"title":"6. Good Practices​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/project_managment/team_management/Communication Plan/backend_communication_plan#6-good-practices","content":" Use asynchronous communication whenever possible.Avoid long or unfocused meetings.Keep all documents updated and accessible.Maintain ongoing comunication through Discord channels for each Team.Encourage frequent feedback. ","version":"Next","tagName":"h2"},{"title":"Team Member's DISC Personality","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/team_management/DISC/frontend_disc","content":"","keywords":"","version":"Next"},{"title":"1. Main Goal​","type":1,"pageTitle":"Team Member's DISC Personality","url":"/leds-tools-public/spark/project_managment/team_management/DISC/frontend_disc#1-main-goal","content":" Understand the pesonality of each member related to SPARK - Frontend Project and how the members of the teams can collaborate better to the development of the project.  ","version":"Next","tagName":"h2"},{"title":"2. DISC Tests Team GPS​","type":1,"pageTitle":"Team Member's DISC Personality","url":"/leds-tools-public/spark/project_managment/team_management/DISC/frontend_disc#2-disc-tests-team-gps","content":" Name\tDominance\tInfluence\tSteadliness\tConscientiounessLarissa Rangel\t12,50%\t45,00%\t35%\t7,50% Gabriel Barbosa\t7.32%\t19.51%\t58.78%\t24.39% Lorhan de Souza\t0%\t12.50%\t57.50%\t30% Thiago Carvalho\t20%\t52%\t15%\t12% Rodolfo\t-----------\t-----------\t-------------\t------------------  ","version":"Next","tagName":"h2"},{"title":"3.DISC Tests Team PS​","type":1,"pageTitle":"Team Member's DISC Personality","url":"/leds-tools-public/spark/project_managment/team_management/DISC/frontend_disc#3disc-tests-team-ps","content":" Name\tDominance\tInfluence\tSteadliness\tConscientiounessBruno Chevitarese\t37.50%\t7.50%\t22.50%\t32.50% Henrique de Souza Lima\t17.50%\t5%\t47.50%\t30% Guilherme Borges Cabral\t7%\t7%\t27%\t57% Nicolas Duarte Botelho\t20%\t12.50%\t25%\t42.50% Lucas Bruno Alves\t22.50%\t30%\t27.50%\t20% ","version":"Next","tagName":"h2"},{"title":"Back-end Team Topology","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology","content":"","keywords":"","version":"Next"},{"title":"👥 Team Topology – SPARK​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology#-team-topology--spark","content":" ","version":"Next","tagName":"h2"},{"title":"📦 Team: Backend (Responsible Group)​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology#-team-backend-responsible-group","content":" Type: Stream-aligned team Mission: Build the core services and API of SPARK using Python, Java, and .NET, enabling the platform to interact with the front-end and process the generated .spark files. Main Deliverables: REST APIs built with Django (Python), Spring Boot (Java), and .NET (Minimal API or Clean Architecture with CQRS)Data validation and processingIntegration with the front-end through clear API endpointsBackend usage documentation and API referenceScalable and maintainable codebase Main Technologies: Python (Django)Java (Spring Boot).NET (Minimal API or Clean Architecture with CQRS)PostgreSQL (or any other DB technology)GitHub    ","version":"Next","tagName":"h3"},{"title":"🛠️ Collaborating Team: Frontend​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology#️-collaborating-team-frontend","content":" Type: Enabling teamRole: Provide support to the back-end team by defining clear API specifications, assisting in data validation, and ensuring smooth integration with the front-end via API endpoints.    ","version":"Next","tagName":"h3"},{"title":"📚 Documentation​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology#-documentation","content":" Documentation hosted on DocusaurusDocumentation structure: Project overviewTechnologies usedDISC profiles of team membersBacklogCommunication PlanTeam Topology    ","version":"Next","tagName":"h3"},{"title":"🔄 Collaboration Format​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology#-collaboration-format","content":" Weekly summaries: Each team provides updates on what has been accomplished, what is pending, and the upcoming tasks for the week.Group reviews: Reviews are conducted whenever major milestones are reached, either asynchronously or through video calls.    ","version":"Next","tagName":"h3"},{"title":"💬 Communication​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/backend_teamtopology#-communication","content":" Main channel: Discord (dedicated channel per team)Quick support: WhatsApp/DiscordTask management: GitHub Issues/Kanban for sprint management ","version":"Next","tagName":"h3"},{"title":"Back-end Team Envolved","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/team_management/DISC/backend_disc","content":"","keywords":"","version":"Next"},{"title":"Team DISC Profiles​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/project_managment/team_management/DISC/backend_disc#team-disc-profiles","content":" Our team has taken the DISC assessment to identify each member's behavioral profile. This helps us better understand our strengths, working styles, and how we can collaborate more effectively.    ","version":"Next","tagName":"h2"},{"title":"Dominance (D)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/project_managment/team_management/DISC/backend_disc#dominance-d","content":" People with a Dominant profile are result-oriented, quick decision-makers, and thrive on challenges. They are great at leading initiatives and solving problems efficiently.  Caio Chiabai de Oliveira     ","version":"Next","tagName":"h3"},{"title":"Influence (I)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/project_managment/team_management/DISC/backend_disc#influence-i","content":" The Influence profile is associated with communicative, enthusiastic, and motivating individuals. They tend to inspire others and create a positive work environment.  Lucas Codeco     ","version":"Next","tagName":"h3"},{"title":"Steadiness (S)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/project_managment/team_management/DISC/backend_disc#steadiness-s","content":" People with this profile are patient, collaborative, and focused on maintaining harmony. They are reliable and consistent in their work.  Murilo Dias Arthur Valentim Caldeira Bruno Alves De Morais     ","version":"Next","tagName":"h3"},{"title":"Conscientiousness (C)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/project_managment/team_management/DISC/backend_disc#conscientiousness-c","content":" The Conscientiousness profile values rules, precision, and quality. These individuals are detail-oriented, analytical, and committed to technical excellence.  Diego Bourguignon Rangel  ","version":"Next","tagName":"h3"},{"title":"Generated Documentation","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/documentationArchitecture","content":"","keywords":"","version":"Next"},{"title":"Generated Hierarchy​","type":1,"pageTitle":"Generated Documentation","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/documentationArchitecture#generated-hierarchy","content":" ","version":"Next","tagName":"h2"},{"title":"Package Diagram​","type":1,"pageTitle":"Generated Documentation","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/documentationArchitecture#package-diagram","content":" A PlantUML file named packagediagram.puml is generated, containing all packages in the Spark file; andA corresponding Markdown file is also created, which embeds the package diagram and lists all of it's packages.  ","version":"Next","tagName":"h3"},{"title":"Packages​","type":1,"pageTitle":"Generated Documentation","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/documentationArchitecture#packages","content":" For each package (also referred to as a module), Spark creates a dedicated folder. Each folder contains:  classdiagram.puml: a PlantUML file describing the classes within the package, including their attributes and relationships.A Markdown file documenting the classes in the package, similar in structure to the package diagram file.  ","version":"Next","tagName":"h3"},{"title":"Terminology Note​","type":1,"pageTitle":"Generated Documentation","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/documentationArchitecture#terminology-note","content":" In the documentation, the terms packages and classes are used. However, in Spark grammar these are referred to as modules and entities, respectively. In other words:  Package = ModuleClass = Entity ","version":"Next","tagName":"h2"},{"title":"Atention","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/Architecture/overview","content":"Atention The architecture description was based on the most recent version in the Main branch of the Spark source repository, namely November 2024. Breif The Spark is a tool developed with Andes and is used as a plugin in VSCode, which forces its architecture to resemble other projects that have the same characteristics. Observe the graph below to have an overview of the architecture. Note that the folders are divided into two sections: the top and the bottom ones. Unfortunately, the code in the main branch of the repository is not stable, making it impossible to fully explain the completeness and exact communication between the layers. However, it is still possible to interpret their intended purpose. Thus, the top layer are explained in an incomplete and interpretive manner, while the bottom layer will be explained in detail.","keywords":"","version":"Next"},{"title":"Front-end Team Topology","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology","content":"","keywords":"","version":"Next"},{"title":"👥 Team Topology – SPARK​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology#-team-topology--spark","content":" ","version":"Next","tagName":"h2"},{"title":"📦 Team: Frontend (Responsible Group)​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology#-team-frontend-responsible-group","content":" Type: Stream-aligned team Mission: Develop a modern, understandable, and accessible interface for SPARK using Vue.js and Tailwind, enabling better user interaction with the platform. Main Deliverables: Interface built with Vue 3 + TailwindCSSGraphical and interactive visualization of entities and relationshipsIntegration with .spark filesInformative dashboardsClear frontend usage documentation Main Technologies: Vue.js 3TailwindCSSViteGitHub    ","version":"Next","tagName":"h3"},{"title":"🛠️ Collaborating Team: Backend​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology#️-collaborating-team-backend","content":" Type: Enabling teamRole: Provide technical support to the frontend team regarding the structure and rules of .spark files, data validation, and communication with generated services.    ","version":"Next","tagName":"h3"},{"title":"📚 Documentation​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology#-documentation","content":" Documentation hosted on DocusaurusDocumentation structure: Project overviewTechnologies usedDISC profiles of team membersBacklogCommunication PlanTeam Topology    ","version":"Next","tagName":"h3"},{"title":"🔄 Collaboration Format​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology#-collaboration-format","content":" Weekly summaries: Every week, each group posts a summary of what was done, pending tasks, and next steps.Group reviews: Whenever a stage is completed, a collective review will be conducted (async or via call).    ","version":"Next","tagName":"h3"},{"title":"💬 Communication​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/project_managment/team_management/Team Topology/frontend_teamtopology#-communication","content":" Main channel: Discord (dedicated channel per team)Quick support: WhatsAppTask management: ","version":"Next","tagName":"h3"},{"title":"Welcome to Src Folder!","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/overview","content":"","keywords":"","version":"Next"},{"title":"Syntax Definition Files","type":1,"pageTitle":"Welcome to Src Folder!","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/overview##","content":"These files, represented by the Langium extension (.langium), are responsible for defining how the language’s syntax is structured. Each file contains a set of data that determines which reserved keywords (for context and typing) exist, which keywords are accepted in which contexts, and how they should be interpreted. In short, they define a set of Regular Expressions (Regex).    ","version":"Next","tagName":"h3"},{"title":"Construction Definition Files","type":1,"pageTitle":"Welcome to Src Folder!","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/overview##","content":"These files are represented by JavaScript (.js) and TypeScript (.ts) extensions. They are programming code files that implement specific validation rules for the language, aimed at facilitating the development of language tests.   CLI  This folder is more relevant than the others. Due to its large number of subfolders and files, it will be explained in a separate section.  Extensions  This folder contains the configuration files for Spark as a VSCode extension. It defines which files should be read to extract grammar checkers, editing assistants — for example, automatically inserting a closing &quot;)&quot; when typing an opening &quot;(&quot;, as well as comment characters — and reserved keyword definitions. Additionally, it also registers commands that can be accessed via left-click on files with the .spark extension. ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/Architecture/src_folder/theCliFolder","content":"Introduction The CLI folder contains the necessary files to read the syntax definitions from the language folder, convert them into computational artifacts interpreted by JS/TS, and apply the commands needed to instantiate the project. This structure follows a very interesting principle: each folder contains a corresponding Generate.ts file, which is responsible for generating the directory structure at its level and/or invoking the Generate.ts of the subsequent level. Furthermore, within the context of this level in the CLI folder, each subfolder refers to a specific command and, depending on the layer, may include subdirectories for more specific application configurations. With these mechanisms, the code becomes not only extremely organized but also allows a clear visualization of the internal layer architectures without the need for diagramming. Understanding the Generate Structure Better Consider the following example code: Configuration { software_name: &quot;Example Software&quot; // Software's name about: &quot;This software is just an example&quot; // Description about the software language: python // Language and pattern used to develop the software database_name: &quot;DataBase&quot; // Database Name } module CoolModule { entity CoolGuy { name: string } } module BadModule { entity DummyGu { name: string } } When reading the .spark file above, VSCode will begin constructing the selected command by following the folder structure within the CLI level. In this structure, we have the folders: documentation;backend;frontend; andopa. The commands registered in VSCode are: generate project documentation;generate backend;generate frontend; andgenerate authorization; Sound familiar? Thus, each folder represents a command registered in VSCode. When a command is triggered, its specific generate file is located within the folder structure. Suppose you execute the command generate backend. Then, VSCode will call the Generator.ts file inside the CLI folder and pass the parameters defined in the configuration section of the .spark file. The Generator.ts file will then locate the specific generate file corresponding to the provided parameters—in our case, it accesses the backend folder (as the generation command is generate backend), then accesses the python folder (as specified in the project configuration), and finally calls the generate.ts file. The generate.ts file, in turn, understands its internal structure and proceeds to create the necessary folders at its level, continuing to call the respective generate.ts files at lower levels, until the entire folder structure is properly built. As the folders are created, the files belonging to each level are also generated. See Image 7 to check an graphic representation. Image 7: Generate struct representation","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/Architecture/theBottomLayerOverview","content":"","keywords":"","version":"Next"},{"title":"Top Layer​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/theBottomLayerOverview#top-layer","content":"   ","version":"Next","tagName":"h2"},{"title":"Bottom Layer​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/theBottomLayerOverview#bottom-layer","content":"   The bottom layers are the most important parts of the project. This is where the real magic happens.  ","version":"Next","tagName":"h2"},{"title":"Src (Source)​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/theBottomLayerOverview#src-source","content":" The Src folder is automatically generated by a Langium project. It contains the most essential information and definitions of Spark.  ","version":"Next","tagName":"h2"},{"title":"Test​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/theBottomLayerOverview#test","content":" This folder is responsible for maintaining and structuring the Spark tests to ensure the integrity and accuracy of the generated code. ","version":"Next","tagName":"h2"},{"title":"Understanding the Language","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/lang","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#configuration","content":" This constructor allows you to define:  Software NameDescription about the softwareLanguage desired to develop the information systemDatabase name   Configuration { software_name: &quot;SlaveOne&quot; // Software's name about: &quot;Slave One project example&quot; // Description about the software language: python // Language and pattern used to develop the software database_name: &quot;SlaveOneDB&quot; // Database Name }   For the language, we have the options: python, java, csharp-minimal-api, csharp-clean-architecture.  ","version":"Next","tagName":"h2"},{"title":"Class Diagram​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#class-diagram","content":" Spark allows you to organize a class diagram into Modules. The declaration of a module follows this pattern:  module Main { // Components of the module go here }   Inside each module, it is possible to define Entities, relations between entities, and Enums.  entity Project { name: string start_date: date end_date: date budget: decimal client: string sponsor: string goal: string project_father OneToMany Project time OneToMany Time status uses Status } enum Status { Ativo Cancelado Entregue }   ","version":"Next","tagName":"h2"},{"title":"Attribute and Relationship Types​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#attribute-and-relationship-types","content":" Entities have attributes, and the available types are: string, integer, decimal, datetime, date, boolean, uuid, email, cpf, cnpj, zipcode, currency, mobilePhoneNumber, phoneNumber, file, void.  Spark allows the following relationships:  OneToOneOneToManyManyToOneManyToMany  ","version":"Next","tagName":"h2"},{"title":"Use Cases​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#use-cases","content":" Spark provides comprehensive support for modeling use cases, allowing the definition of actors, events, and relationships between use cases.  ","version":"Next","tagName":"h2"},{"title":"Defining Actors​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#defining-actors","content":" Actors represent entities or roles interacting with the system. An actor can optionally extend another actor and include attributes like name.  actor ProjectManager name: &quot;Project Manager&quot; actor TeamMember name: &quot;Team Member&quot;   ","version":"Next","tagName":"h3"},{"title":"Defining Use Cases​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#defining-use-cases","content":" A use case describes a functionality of the system. It can include actors, events, descriptions, and inheritance from other use cases.  usecase ManageProjects extends BaseUseCase { name: &quot;Manage Projects&quot; description: &quot;Handles project management functionalities&quot; performer: ProjectManager, TeamMember event CreateProject { name: &quot;Create a Project&quot; description: &quot;Allows the creation of a new project&quot; action: &quot;Create&quot; } event AssignTask { name: &quot;Assign a Task&quot; description: &quot;Assigns tasks to team members&quot; action: &quot;Assign&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Defining Events​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/spark_advanced/lang#defining-events","content":" Events are integral components of a use case. They represent actions or operations, with optional dependencies on other events.  event CreateProject { name: &quot;Create a Project&quot; description: &quot;Initiates the creation of a project&quot; action: &quot;Create&quot; depend: AssignTask }   Where:  Actors are the performers of the use case.Use Cases define the system's functionality.Events represent discrete operations within a use case. ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer","content":"","keywords":"","version":"Next"},{"title":"Top Layer​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#top-layer","content":"   ","version":"Next","tagName":"h2"},{"title":"Bottom Layer​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#bottom-layer","content":"   The top layer is, to some extent, independent from the others, since there is no communication between them. However, they certainly do communicate in the final and correct version of the tool.  ","version":"Next","tagName":"h2"},{"title":"Bin​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#bin","content":" This folder, normally used to store machine-compiled code, is responsible for containing the files that manage the execution of the available commands. These files are most likely executed via the Command Line Interface (CLI). Since the project is developed with NodeJS, it's possible to use JavaScript (JS) source code to access the system’s operating system calls (SCs). Therefore, there is no need for compiled code in this folder; all files here are JS source code, but their purpose is the same as that of a folder containing binary files.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#examples","content":" The examples folder contains files in the Spark format (.spark) with examples demonstrating how the tool's syntax works.  ","version":"Next","tagName":"h2"},{"title":"Images​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#images","content":" This folder contains images used in the repository’s documentation and in the tool’s documentation within VSCode. It is a folder with static files.  ","version":"Next","tagName":"h2"},{"title":"Models​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#models","content":" This folder is responsible for part of the documentation. It contains files that model the tool's reserved keywords and how they communicate and interact, using the Unified Modeling Language (UML).  The files are in the .vpp format, which is read by the Visual Paradigm tool. The files in question were created with an unidentified version of the tool. The graph below shows the internal content of the only file present in the folder, opened in the most recent version of the tool as of now, version 17.2. Therefore, it is not guaranteed that the internal content in the image is complete.    ","version":"Next","tagName":"h2"},{"title":"Scripts​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#scripts","content":" This folder is responsible for containing some code that will potentially be called by the bin folder but is not part of the CLI. Currently, its files are responsible for preparing the environment with the folder structure, ensuring that the generation of subsequent files does not encounter errors.  ","version":"Next","tagName":"h2"},{"title":"Static​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/spark_advanced/Architecture/understandTopLayer#static","content":" This folder is automatically generated by a Langium project along with Monaco to create static documentation for the tool under development. Since the documentation is now being created separately with an external tool, namely Docusaurus, it has been discontinued and no longer receives updates. ","version":"Next","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/Explanning","content":"","keywords":"","version":"Next"},{"title":"Use in Spark​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/sparklib_advanced/backend/Explanning#use-in-spark","content":" With the use of the lib we needed to modify our source code of the spark generators, where all code generation logic was within the source code, with the use of our lib we removed all this part of the product logic and kept only the lib calls we created, keeping only one generator.ts within each respective language.  This leaves us with the source code structure like this:    These generators are where spark-generators-lib is called for each language, thus communicating with the generators and index within the lib. ","version":"Next","tagName":"h3"},{"title":"Clean Architecture Csharp","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#layered-architecture","content":" The project follows Clean Architecture principles, with independent layers that isolate business rules, application logic, infrastructure, and user interface. Each layer only depends on the one below it, enabling low coupling and high cohesion.    ","version":"Next","tagName":"h2"},{"title":"Domain Layer — Moranguinho.Domain​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#domain-layer--moranguinhodomain","content":" This layer represents the core domain of the system, containing entities, business rules, and fundamental contracts.  Entities/ — Domain Entities​  Contains core entities like Agricultor, Propriedade, etc. Each entity encapsulates specific business behavior such as CPF validation or property area constraints.  Enums/ — Enumerations​  Defines fixed types used in the domain, contains baseEnum.cs.  Interfaces/ — Repository/Service Contracts​  Defines interfaces like IAgricultorRepository, IValidadorPropriedade, enabling dependency inversion and isolated testing.  Validation/ — Validation Rules​  Contains specific validation rules applied directly to entities or value objects.  Common/ — Abstractions and Utilities​  Base classes like BaseEntity, can contain abstractions and utilities.    ","version":"Next","tagName":"h3"},{"title":"Application Layer — Moranguinho.Application​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#application-layer--moranguinhoapplication","content":" Responsible for orchestrating system use cases and bridging presentation and domain layers.  UseCase/ — Use Cases​  Implements application processes like CriarAgricultor, BuscarPropriedadePorId, etc. Receives DTOs from the API and interacts with the domain and repositories. Example: BaseCase.cs.  Services/ — Application Services​  Auxiliary services used by use cases, such as productivity calculations or mapping utilities. Example: BaseService.cs, AgricultorService.cs.  DTOs/ — Data Transfer Objects​  Input and output objects for the application. Example folders: Request/, Response/, and Common/. Files: AgricultorRequest.cs, PropriedadeResponse.cs, etc.  Mappers/ — Object Converters​  Converts between domain entities and DTOs. Manual mapping used in files like AgricultorMapper.cs, PropriedadeMapper.cs.  Interfaces/ — Infrastructure Contracts​  Interfaces for services such as email sending, authentication, and repositories. Implemented in the Infrastructure layer.  Security/ — Security Abstractions​  Rules and contracts for authentication/authorization.  Configuration/ServiceExtensions.cs​  Registers all application services and configurations in the DI container.    ","version":"Next","tagName":"h3"},{"title":"Infrastructure Layer — Moranguinho.Infrastructure​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#infrastructure-layer--moranguinhoinfrastructure","content":" Contains concrete implementations of services and repositories, integrating with external systems like databases, security, etc.  Context/AppDbContext.cs​  EF Core DbContext implementation responsible for database access and entity mappings.  EntitiesConfiguration/​  Fluent API configuration for database mapping. Example: AgricultorConfiguration.cs, PropriedadeConfiguration.cs.  Repositories/​  Implements repositories defined in the domain. Examples: AgricultorRepository.cs, PropriedadeRepository.cs, and base implementations in Common/.  Security/​  Concrete implementations for security concerns, such as UserRepository.cs, RoleRepository.cs under Security/Repositories/.  ServiceExtensions.cs​  Registers infrastructure-level services into the DI container.    ","version":"Next","tagName":"h3"},{"title":"Presentation Layer — Moranguinho.WebAPI​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#presentation-layer--moranguinhowebapi","content":" The system's HTTP entry point, where requests arrive and are translated into application commands.  Controllers/​  Exposes API endpoints like POST /agricultores, GET /propriedades. Controllers: AgricultorController.cs, PropriedadeController.cs.  Extensions/​  Configuration for middleware, CORS, Swagger, authentication, etc. Files include JwtExtension.cs, CorsPolicy.cs, OData.cs.  Program.cs​  Application bootstrap file. Initializes the host, configures services, and defines the HTTP pipeline.  appsettings.json​  Configuration file for database connections, JWT keys, CORS, and API settings.  Scripts/​  Utility SQL scripts such as delete.sql, killdatabase.sql for local development or test resets.    ","version":"Next","tagName":"h3"},{"title":"Testing Layer — Moranguinho.Domain.Test and Moranguinho.Infrastructure.Test​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#testing-layer--moranguinhodomaintest-and-moranguinhoinfrastructuretest","content":" Dedicated layers for automated tests.  Moranguinho.Domain.Test​  Unit tests for domain entities and business rules. Focused on validation, behavior, and isolated logic. Files: AgricultorTest.cs, PropriedadeTest.cs.  Moranguinho.Infrastructure.Test​  Integration tests for repository behavior using EF InMemory. Files in Repositories/: AgricultorRepositoryTest.cs, PropriedadeRepositoryTest.cs. Includes appsettings.json and xunit.runner.json for test environment setup.  Testing framework: xUnit.    ","version":"Next","tagName":"h3"},{"title":". References​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#-references","content":" .NET - Usando a Clean Architecture - Jose Carlos MacorattiGithub CleanArchitecture - jasontaylordevGithub Clean Architecture Template - amantinband    ","version":"Next","tagName":"h2"},{"title":". Improvement Points​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Clean#-improvement-points","content":" Clearer Layer Separation: Ensure distinct responsibilities for each layer, avoiding overlap of concerns between the Application, Domain, and Infrastructure layers. Use of AutoMapper: Implement AutoMapper or similar libraries to simplify and automate the mapping between domain entities and DTOs, reducing boilerplate code and improving maintainability. ","version":"Next","tagName":"h2"},{"title":"Spark Compiler Artifact Map","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/artifact_map","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Spark Compiler Artifact Map","url":"/leds-tools-public/spark/sparklib_advanced/backend/artifact_map#introduction","content":" The Spark compiler receives models defined in its own language and generates code for different technologies (Java, Python, C#, etc.). Each language object (Entity, Enum, Service, etc.) is converted into specific artifacts, distributed in folders and files according to each generator's architecture.  ","version":"Next","tagName":"h2"},{"title":"Mapping Language Objects to Artifacts​","type":1,"pageTitle":"Spark Compiler Artifact Map","url":"/leds-tools-public/spark/sparklib_advanced/backend/artifact_map#mapping-language-objects-to-artifacts","content":" Language Object\tGenerated Artifact (Java)\tGenerated Artifact (Python)\tGenerated Artifact (C# Minimal API)\tGenerated Artifact (C# Clean Architecture)Entity\tjava-generator/entity/model-generator.ts (Java class in Entity/)\tpython-generator/django/back/ (Django Model class)\tcsharp-generator/minimal-API-generator/webservice/model-generator.ts (C# class in Entities/)\tcsharp-generator/cleanArchitecture-generator/Domain/Entities/ (C# class in Entities/) Enum\tjava-generator/entity/enum-generator.ts (Java enum in Enums/)\tpython-generator/django/back/ (Python enum)\tcsharp-generator/minimal-API-generator/webservice/enum-generator.ts (C# enum in Enums/)\tcsharp-generator/cleanArchitecture-generator/Domain/Enums/ (C# enum in Enums/) Service\tjava-generator/entity/service-generator.ts (Java class in Services/)\tpython-generator/django/back/ (Python Service class)\tcsharp-generator/minimal-API-generator/webservice/generator.ts (C# class in Services/)\tcsharp-generator/cleanArchitecture-generator/Application/Services/ (C# class in Services/) DTO\tjava-generator/entity/dto-generator.ts (Java class in DTOs/)\tpython-generator/django/back/ (Python DTO class)\tcsharp-generator/minimal-API-generator/webservice/dto-generator.ts (C# class in DTOs/)\tcsharp-generator/cleanArchitecture-generator/Application/DTOs/ (C# class in DTOs/) Interface\tjava-generator/entity/interface-generator.ts (Java interface)\tpython-generator/django/back/ (Python interface)\tcsharp-generator/minimal-API-generator/webservice/interface-generator.ts (C# interface)\tcsharp-generator/cleanArchitecture-generator/Domain/Interfaces/ (C# interface) Validation\tjava-generator/entity/validation-generator.ts (Java class in Validation/)\tpython-generator/django/back/ (Python Validation class)\tcsharp-generator/minimal-API-generator/webservice/validation-generator.ts (C# class in Validation/)\tcsharp-generator/cleanArchitecture-generator/Domain/Validation/ (C# class in Validation/) Configuration\tjava-generator/webservice/config-generator.ts (Configuration file)\tpython-generator/django/back/ (Configuration file)\tcsharp-generator/minimal-API-generator/webservice/config-generator.ts (Configuration file)\tcsharp-generator/cleanArchitecture-generator/Application/Configuration/ (Configuration file)  ","version":"Next","tagName":"h2"},{"title":"Examples of Generated Paths​","type":1,"pageTitle":"Spark Compiler Artifact Map","url":"/leds-tools-public/spark/sparklib_advanced/backend/artifact_map#examples-of-generated-paths","content":" Java: packages/java-generator/entity/model-generator.ts → Generates files in Entity/, Enums/, Services/, etc.Python: packages/python-generator/django/back/ → Generates models, enums, services, etc.C# Minimal API: packages/csharp-generator/minimal-API-generator/webservice/ → Generates entities, enums, services, DTOs, etc.C# Clean Architecture: packages/csharp-generator/cleanArchitecture-generator/Domain/, Application/, etc.  ","version":"Next","tagName":"h2"},{"title":"Notes​","type":1,"pageTitle":"Spark Compiler Artifact Map","url":"/leds-tools-public/spark/sparklib_advanced/backend/artifact_map#notes","content":" The mapping may vary depending on the target technology and project configuration.For specific details, check each generator's files in the packages folder.    This map serves as a quick reference to understand how each Spark language object is converted into code artifacts in the different architectures supported by the compiler. ","version":"Next","tagName":"h2"},{"title":"Java Spark Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#layered-architecture","content":" Backend development in Java was structured in layers, organizing the system in hierarchies, each with its own responsibilities. The division was made as follows:    ","version":"Next","tagName":"h2"},{"title":"Data Layer​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#data-layer","content":" Responsible for entities and repositories (entity/ folder).  ","version":"Next","tagName":"h3"},{"title":"Application/API Layer​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#applicationapi-layer","content":" Includes controllers and exposed services (webservice/ folder).  This structure facilitated maintenance, testability, and the reuse of components.    ","version":"Next","tagName":"h3"},{"title":"Main Folders​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#main-folders","content":" ","version":"Next","tagName":"h2"},{"title":"Entity​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#entity","content":" models/​  Contains Java classes corresponding to entities defined in the .spark file (e.g., Agricultor, Propriedade). These entities reflect database tables and include JPA annotations.  repositories/​  Database access interfaces such as AgricultorRepository.java, which extend JpaRepository and are used for queries.  sql/​  SQL scripts useful for data replication setup and database constraint creation.  register/​  Stores project metadata, such as the morango-register.json file, which registers information about created modules and entities.  resources/​  Application configuration files such as application.properties, containing Spring Boot configurations.  ","version":"Next","tagName":"h3"},{"title":"Webservice​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#webservice","content":" Service exposure layer of the application. This is where application logic interfaces with the outside world (frontend or API consumers).  application/​  Contains the Application.java class that initializes the Spring Boot project.  controllers/​  REST/GraphQL controllers generated for each entity. Handle requests and define endpoints.  records/​  DTOs (Data Transfer Objects), which carry input and output data of the API. Example: AgricultorInput.java.  repositories/​  Serve as adapters between controllers and domain-layer repositories.  resources/graphql/​  Contains the schema.graphqls file, which defines the types, queries, and mutations of the GraphQL API, based on the entities defined in the .spark file.    ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#references","content":" https://www.alura.com.br/artigos/padroes-arquiteturais-arquitetura-software-descomplicadahttps://jeziellago.medium.com/padr%C3%B5es-de-arquitetura-de-software-parte-i-a1d23c323a40    ","version":"Next","tagName":"h2"},{"title":"Improvement Points​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Java#improvement-points","content":" Better naming of web repositories: AgricultorRepositoryWeb.java can be confused with AgricultorRepository.java. More specific names like AgricultorGraphQLAdapter would prevent such issues we encountered during analysis.Creation of a service layer: Adding an intermediate layer between controllers and repositories with pure business logic would increase separation of concerns. ","version":"Next","tagName":"h2"},{"title":"C# Minimal API Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#layered-architecture","content":" The backend follows a modular layered architecture, organizing components by domain and functionality. Each layer has a defined responsibility, as shown below:    ","version":"Next","tagName":"h2"},{"title":"Presentation Layer​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#presentation-layer","content":" Located in the Webservice/ folder.  Contains the Program.cs file, responsible for configuring and exposing HTTP routes, middlewares (Swagger, CORS, authentication), and app services.Acts as the UI of the API, handling direct interaction with clients.  ","version":"Next","tagName":"h3"},{"title":"Domain Layer​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#domain-layer","content":" Located in the Moranguinho/ folder.  Includes domain-specific logic and models such as Agricultor.cs, Propriedade.cs, and ContextDbFactory.cs.Organizes code by feature, improving maintainability and separation of concerns.  ","version":"Next","tagName":"h3"},{"title":"Shared Layer​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#shared-layer","content":" Located in the Shared/ folder.  Provides cross-cutting utilities and shared components like models, enums, and helper classes.Contains the ContextDb/ subfolder, which handles database access using EF Core (Entity Framework Core).  This structure enables a clean separation between domain logic, infrastructure, and service exposure.    ","version":"Next","tagName":"h3"},{"title":"Main Folders​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#main-folders","content":" ","version":"Next","tagName":"h2"},{"title":"Webservice​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#webservice","content":" Service exposure layer of the application.  Program.cs​  Initializes and configures the Minimal API app, sets up services, middlewares, and routes.  Endpoints and Middleware​  Responsible for exposing routes to external consumers, including Swagger setup, CORS policy, and authentication (if applicable).    ","version":"Next","tagName":"h3"},{"title":"Moranguinho​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#moranguinho","content":" Represents the core domain logic.  Agricultor.cs​  Defines the Agricultor entity and related domain logic.  Propriedade.cs​  Represents the Propriedade entity, modeling the domain structure for rural properties.  ContextDbFactory.cs​  A factory class used to instantiate the DbContext, especially useful for dependency injection or testing scenarios.    ","version":"Next","tagName":"h3"},{"title":"Shared​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#shared","content":" Shared resources and infrastructure.  ContextDb/​  Contains:  DbContext definition used by EF CoreEntity configurations and model mappingsResponsible for database interaction (CRUD operations, migrations, etc.)  Used across the entire application to maintain a centralized and consistent data access approach.    ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#references","content":" https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apishttps://www.infoq.com/articles/minimal-api-dotnet6/https://learn.microsoft.com/en-us/ef/core/    ","version":"Next","tagName":"h2"},{"title":"Improvement Points​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Csharp_Minimal-API#improvement-points","content":" Add Service Layer (optional): Including a service layer between endpoints and domain classes could improve the separation of business logic.Program.cs too big: Create the service layer, and routes configurations ","version":"Next","tagName":"h2"},{"title":"Back-end Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/backend_architeture","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Back-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/backend_architeture#overview","content":" The generators, written in TypeScript, create the code, files, and folder structure for back-end applications in different languages.  Each language has a main generator that orchestrates the creation of the folder structure and calls the specific generators for each part of the application.    ","version":"Next","tagName":"h2"},{"title":"Generators by Language​","type":1,"pageTitle":"Back-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/backend_architeture#generators-by-language","content":" ","version":"Next","tagName":"h2"},{"title":"C#​","type":1,"pageTitle":"Back-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/backend_architeture#c","content":" The architecture for C# follows the Clean Architecture pattern.  └── backend/csharp/ └── clean-architecture-custom/ ├── project-generator.ts ├── Application/ │ ├── project-generator.ts │ └── generate.ts ├── Domain/ │ ├── project-generator.ts │ └── generate.ts ├── Infrastructure/ │ ├── project-generator.ts │ └── generate.ts └── WebAPI/ ├── project-generator.ts └── Controllers/ └── generate.ts   Generator Organization​  Main Generator: Creates the main solution file (.sln) which references the project files for the Domain, Application, Infrastructure, and WebAPI layers. Domain: Defines the business rules and entities. The project-generator.ts file creates the .csproj for the Domain layer. It includes references to NuGet packages such as EmailValidation, Flunt, and Serilog. Application: Contains the use cases and services. The project-generator.ts generates the .csproj for the Application layer. It references the Domain layer and includes packages like AutoMapper, DocsBRValidator, MediatR, and FluentValidation. Infrastructure: Provides implementation details for services defined in Domain and Application. Its project-generator.ts creates the .csproj and includes packages such as Microsoft.EntityFrameworkCore.SqlServer and SendGrid. WebAPI: Entry point for the application. The generate.ts in the Controllers directory generates the C# controllers (CRUD and other use cases).    ","version":"Next","tagName":"h3"},{"title":"Java​","type":1,"pageTitle":"Back-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/backend_architeture#java","content":" The architecture for Java uses the Spring Boot framework.  . └── backend/ └── java/ └── generator.ts   Generator Organization​  Main Generator: The generator.ts file is the entry point for Java code generation. It creates the target directory and then calls the specific generator function for Spring Boot to create the project.    ","version":"Next","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Back-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/backend_architeture#python","content":" The architecture for Python uses the Django framework.  └── backend/ └── python/ └── generator.ts   Generator Organization​  Main Generator: The generator.ts file is the entry point for Python code generation. It creates the target directory and then calls the specific generator function for Django to create the project. ","version":"Next","tagName":"h3"},{"title":"Metamodel","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/spark_advanced/metamodel","content":"","keywords":"","version":"Next"},{"title":"Model​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#model","content":"   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#configuration","content":" Description: Represents the configuration settings of the system. This class is imported from the config package.Attributes: (Attributes are defined within the config package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"AbstractElement​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#abstractelement","content":" Description: An abstract representation of system elements. It serves as a base for more specific elements like Module and EnumX.Relationships: Inheritance: Module and EnumX inherit from AbstractElement.  ","version":"Next","tagName":"h3"},{"title":"ModuleImport​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#moduleimport","content":" Description: Represents an import statement for modules. This class is imported from the modules package.Attributes: (Attributes are defined within the modules package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Actor​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#actor","content":" Description: Represents an actor in the system, typically a user or external system that interacts with the system's use cases.Attributes: (Attributes are defined within the entities or usescases package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#usecase","content":" Description: Represents a use case within the system, defining a specific functionality or behavior that actors can perform.Attributes: (Attributes are defined within the usescases package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#module","content":" Description: Represents a module within the system, which can contain various elements such as other modules, enums, or local entities.Attributes: name: A QualifiedName that uniquely identifies the module.comment: An optional Comment providing additional information about the module.elements: A collection of AbstractElement or LocalEntity instances contained within the module. Relationships: Has: May contain one Comment.Contains: Can contain multiple AbstractElement and LocalEntity instances.  ","version":"Next","tagName":"h3"},{"title":"EnumX​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#enumx","content":" Description: Represents an enumeration within the system. Inherits from AbstractElement.Attributes: (Attributes specific to the enumeration are defined within the entities package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"LocalEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#localentity","content":" Description: Represents a local entity within a module. This could be a class, interface, or other construct defined within a module.Attributes: (Attributes are defined within the entities package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Comment​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#comment","content":" Description: Represents a comment within the grammar, providing additional context or explanations for modules.Attributes: content: A string containing the comment text.  ","version":"Next","tagName":"h3"},{"title":"QualifiedName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#qualifiedname","content":" Description: Represents a qualified name used to uniquely identify elements within the system. Imported from the terminals package.Attributes: (Attributes are defined within the terminals package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#configuration-1","content":" This class diagram provides a clear and organized view of the Configuration class within the SPARK grammar, demonstrating how it integrates various fragments to encapsulate different aspects of the system's configuration. By using fragments such as DataBaseName, Language, PackagePath, and Features, the model promotes reusability and consistency, ensuring that common configuration patterns are maintained across different components of the system. The optional association between Features and Entity allows for enhanced flexibility, enabling features to be contextually linked to specific entities as needed.    ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#configuration-2","content":" Description: The Configuration class encapsulates the system's configuration settings. It includes various attributes that define the software's name, description, database configuration, package paths, programming language, and feature settings. Attributes: name: A string representing the name of the software.description: A string providing an overview or details about the software.dataBaseName: An instance of the DataBaseName fragment specifying the database name.packagePath: An instance of the PackagePath fragment specifying the package path.language: An instance of the Language fragment specifying the programming language used.features: An instance of the Features fragment defining various features of the software. Relationships: Includes: DataBaseName: Defines the name of the database.PackagePath: Specifies the package path used in the system.Language: Indicates the programming language employed.Features: Details the features available, optionally associating them with specific entities.  ","version":"Next","tagName":"h3"},{"title":"DataBaseName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#databasename","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Specifies the name of the database used by the system.Attributes: database_name: A string representing the database name.  ","version":"Next","tagName":"h3"},{"title":"Language​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#language","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Specifies the programming language used in the system.Attributes: language: An enumeration (LANGUAGETYPE) representing the programming language (e.g., Java, Python).  ","version":"Next","tagName":"h3"},{"title":"PackagePath​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#packagepath","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Specifies the package path used in the system.Attributes: package_path: An enumeration (LANGUAGETYPE) representing the package path.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#features","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Defines features of the system, optionally associating them with specific entities.Attributes: feature: An enumeration (FEATURE_TYPE) representing the type of feature.entity: An optional reference to an Entity using a QualifiedName.  ","version":"Next","tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#entity","content":"   ","version":"Next","tagName":"h2"},{"title":"Entity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#entity-1","content":" Description: The Entity interface is implemented by both LocalEntity and ImportedEntity. This allows these classes to be treated uniformly when establishing relationships and dependencies.Inheritance: LocalEntity ..|&gt; EntityImportedEntity ..|&gt; Entity  ","version":"Next","tagName":"h3"},{"title":"ModuleImport​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#moduleimport-1","content":" Description: Represents an import statement for modules. It specifies the package path, library, module name, and the entities being imported.Attributes: package_path: The path of the package as a string.library: The name of the library from which modules are imported.name: The name of the module.entities: A list of ImportedEntity instances representing the entities being imported. Relationships: Imports: Can import multiple ImportedEntity instances.  ","version":"Next","tagName":"h3"},{"title":"ImportedEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#importedentity","content":" Description: Represents an entity that is imported into a module. It holds the name of the entity.Attributes: name: The name of the imported entity.  ","version":"Next","tagName":"h3"},{"title":"LocalEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#localentity-1","content":" Description: Represents a local entity within a module. This could be a class, interface, or other construct defined within a module.Attributes: name: The name of the entity.superType: An optional reference to another Entity that this entity extends.is_abstract: A boolean flag indicating whether the entity is abstract.attributes: A collection of Attribute instances defining the entity's attributes.enumEntityAttributes: A collection of EnumEntityAtribute instances.relations: A collection of Relation instances defining relationships with other entities.functions: A collection of FunctionEntity instances defining the entity's functions. Relationships: Inherits: Implements the Entity interface.Contains: Can contain multiple Attribute, EnumEntityAtribute, Relation, and FunctionEntity instances.Has: May have an optional Comment.  ","version":"Next","tagName":"h3"},{"title":"FunctionEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#functionentity","content":" Description: Represents a function within an entity, detailing its name, parameters, and return type.Attributes: name: The name of the function.response: The data type of the function's return value.parameters: A collection of Parameter instances defining the function's parameters. Relationships: Has: Can contain multiple Parameter instances.  ","version":"Next","tagName":"h3"},{"title":"Parameter​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#parameter","content":" Description: Represents a parameter of a function within an entity.Attributes: elements: A collection of Element instances defining the parameter's elements. Relationships: Includes: Can contain multiple Element instances.  ","version":"Next","tagName":"h3"},{"title":"Element​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#element","content":" Description: Represents an individual element within a parameter, specifying its name and type.Attributes: name: The name of the element.type: The data type of the element.  ","version":"Next","tagName":"h3"},{"title":"Attribute​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#attribute","content":" Description: Represents an attribute of an entity, detailing its name, type, and various constraints.Attributes: name: The name of the attribute.type: The data type of the attribute.fullName: An optional string specifying the full name.unique: An optional boolean indicating if the attribute is unique.blank: An optional boolean indicating if the attribute can be blank.max: An optional integer specifying the maximum value.min: An optional integer specifying the minimum value.  ","version":"Next","tagName":"h3"},{"title":"EnumEntityAtribute​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#enumentityatribute","content":" Description: Represents an attribute of an enumeration within an entity.Attributes: name: The name of the enumeration attribute.type: A reference to an EnumX instance indicating the type of the enumeration.  ","version":"Next","tagName":"h3"},{"title":"EnumX​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#enumx-1","content":" Description: Represents an enumeration type within the system.Attributes: name: The name of the enumeration.attributes: A collection of AttributeEnum instances defining the enumeration's attributes. Relationships: Contains: Can contain multiple AttributeEnum instances.  ","version":"Next","tagName":"h3"},{"title":"AttributeEnum​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#attributeenum","content":" Description: Represents a single attribute within an enumeration.Attributes: name: The name of the enumeration value.fullName: An optional string specifying the full name of the enumeration value.  ","version":"Next","tagName":"h3"},{"title":"Relation (Abstract Class)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#relation-abstract-class","content":" Description: An abstract class representing relationships between entities. Specific types of relationships (OneToOne, OneToMany, ManyToOne, ManyToMany) inherit from this class.  OneToOne​  Description: Represents a one-to-one relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.  OneToMany​  Description: Represents a one-to-many relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.  ManyToOne​  Description: Represents a many-to-one relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.  ManyToMany​  Description: Represents a many-to-many relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.by: An optional reference to a LocalEntity that mediates the relationship.  ","version":"Next","tagName":"h3"},{"title":"QualifiedName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#qualifiedname-1","content":" Description: Represents a qualified name used to uniquely identify elements within the system. It typically follows the format ID(.ID)*, allowing for hierarchical naming.Attributes: id: A string representing the qualified name, composed of one or more identifiers separated by dots (e.g., com.example.project).  ","version":"Next","tagName":"h3"},{"title":"Comment​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#comment-1","content":" Description: Represents a comment within the grammar, providing additional context or explanations for modules or other elements.Attributes: content: A string containing the comment text.  ","version":"Next","tagName":"h3"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#usecase-1","content":" This class diagram focuses on the Actor and UseCase elements defined in your SPARK grammar. It includes related classes such as Entity, QualifiedName, and Comment to fully represent the structure and relationships within your metamodel.    ","version":"Next","tagName":"h2"},{"title":"Actor​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#actor-1","content":" Description: Represents an actor within the system, typically a user or external system that interacts with use cases.Attributes: name: A QualifiedName that uniquely identifies the actor.entity: An Entity that the actor is associated with.superType: An optional reference to another Actor that this actor extends. Relationships: Is: Each Actor is associated with one Entity.Extends: An Actor can optionally extend another Actor, establishing an inheritance relationship.  ","version":"Next","tagName":"h3"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#usecase-2","content":" Description: Represents a use case within the system, defining a specific functionality or behavior that actors can perform.Attributes: name: A QualifiedName that uniquely identifies the use case.superType: An optional reference to another UseCase that this use case extends.fullName: A string representing the full name of the use case.kind: An enumeration (Kind) indicating the type of use case (manage or view).performed: A collection of Actor instances that perform this use case.models: A collection of Entity instances that are involved in this use case.extend: An optional collection of UseCase instances that this use case extends.include: An optional collection of UseCase instances that this use case includes. Relationships: Extends: A UseCase can optionally extend another UseCase, establishing an inheritance relationship.Includes: A UseCase can optionally include other UseCase instances.Performed By: A UseCase is performed by one or more Actor instances.Models: A UseCase involves one or more Entity instances.  ","version":"Next","tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#entity-2","content":" Description: An interface implemented by various entity classes (LocalEntity, ImportedEntity, etc.). Represents any entity within the system.Attributes: None (serves as a marker interface).Relationships: Implemented By: Actor implements the Entity interface.  ","version":"Next","tagName":"h3"},{"title":"QualifiedName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#qualifiedname-2","content":" Description: Represents a qualified name used to uniquely identify elements within the system. Typically follows the format ID(.ID)*, allowing for hierarchical naming.Attributes: id: A string representing the qualified name, composed of one or more identifiers separated by dots (e.g., com.example.project).  ","version":"Next","tagName":"h3"},{"title":"Kind (Enumeration)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/spark_advanced/metamodel#kind-enumeration","content":" Description: Defines the type of use case.Values: manageview ","version":"Next","tagName":"h3"},{"title":"Django Project Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Python","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Python#layered-architecture","content":"   The project follows a modular, domain-driven layered architecture. This structure facilitates the separation of responsibilities, system scalability, and ease of maintenance and testing. Below, we detail each layer and component with examples of their responsibilities.  ","version":"Next","tagName":"h2"},{"title":"Domain Layer — apps/moranguinho/​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Python#domain-layer--appsmoranguinho","content":" This folder represents a Django application specific to a system domain: the management of farmers and properties. Each functionality related to this domain is grouped here, promoting modularity and functional cohesion.  models.py — Data Models​  The models represent the core entities of the system, such as Farmer and Property. Each model is linked to a database table, and its attributes reflect the table's columns. Business rules related to data behavior may also be included here.  api_views.py — API Controllers​  This file contains the interfaces that handle REST API requests. These controllers receive user requests, delegate logic to appropriate layers, and return responses. Examples include listing farmers, creating properties, and updating records.  serializers.py — Serialization and Validation​  Serializers convert Python objects into formats like JSON and handle both automatic and custom data validation. They act as an intermediary between database records and user-facing responses.  pagination.py, utils.py, signals.py — Supporting Features​  pagination.py: Manages pagination of list views.utils.py: Contains reusable utility functions (e.g., formatting, calculations).signals.py: Handles automatic actions triggered by events (e.g., creation of a new farmer).  test/ and features/ — Testing Layer​  test/: Contains unit and integration tests for component isolation.features/: Stores behavior-driven development (BDD) tests using Gherkin to simulate user behavior.  migrations/ — Database Version Control​  This folder includes Django migration files that track changes to the database schema over time, enabling safe evolution of the data model.  ","version":"Next","tagName":"h3"},{"title":"Global Project Settings — morango/​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Python#global-project-settings--morango","content":" This directory contains the core configuration files of the Django project.  settings.py: Defines project-wide settings such as database configuration, installed apps, middleware, and REST framework settings.urls.py: Defines main routes for the API and Django admin panel.wsgi.py and asgi.py: Handle communication between web servers and the application.    ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Python#references","content":" Django Official DocumentationDecoding DDD: A Three-Tiered Approach to Django Projects – DjangoCon US    ","version":"Next","tagName":"h2"},{"title":"Improvement Points​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/sparklib_advanced/backend/generated_arch/Python#improvement-points","content":" Project with growth potential: Split the moranguinho app into multiple smaller apps, such as farmers, properties, and reports. Each app would target a specific subdomain, improving maintenance, cohesion, and testability. ","version":"Next","tagName":"h2"},{"title":"Artifact Mapper","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map","content":"","keywords":"","version":"Next"},{"title":"Configuration Files (root)​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#configuration-files-root","content":" Artifact\tType\tDescription.browserslistrc\tConfiguration\tDefines browser support for build/transpilation. .editorconfig\tConfiguration\tCode style rules for editors. .env.dev\tConfiguration\tEnvironment variables for development. .gitignore\tConfiguration\tFiles/folders ignored by Git. package.json / package-lock.json\tDependencies\tDefines project dependencies and scripts. tsconfig.*.json\tTypeScript Config\tTypeScript compilation settings. vite.config.mts\tBuild Config\tVite bundler configuration. index.html\tBase Document\tMain HTML where the Vue app is mounted. components.d.ts / env.d.ts\tGlobal Typings\tGlobal TypeScript type definitions.    ","version":"Next","tagName":"h2"},{"title":"public/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#public","content":" Artifact\tType\tDescriptionfavicon.png\tStatic\tWebsite favicon. assets/images/\tStatic\tPublic images directly accessible.    ","version":"Next","tagName":"h2"},{"title":"src/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#src","content":" ","version":"Next","tagName":"h2"},{"title":"Main Files​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#main-files","content":" Artifact\tType\tDescriptionApp.vue\tVue Root\tRoot component of the application. main.ts\tEntry\tApplication entry point (mounts App and initializes plugins).  ","version":"Next","tagName":"h3"},{"title":"api/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#api","content":" Artifact\tType\tDescription*.ts\tServices\tInterfaces for API access (HTTP requests).  ","version":"Next","tagName":"h3"},{"title":"assets/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#assets","content":" Artifact\tType\tDescriptionlogo.png/svg\tStatic\tApplication logos. style.css\tStylesheet\tGlobal styles.  ","version":"Next","tagName":"h3"},{"title":"components/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#components","content":" Artifact\tType\tDescriptionCard.vue, DataTable.vue…\tUI Reusable\tGeneric reusable UI components. icons/\tUI\tCustom icons. sidenav/\tUI\tSidebar navigation components.  ","version":"Next","tagName":"h3"},{"title":"layouts/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#layouts","content":" Artifact\tType\tDescriptionDefault.vue, Plain.vue…\tLayouts\tPage skeletons (layout templates).  ","version":"Next","tagName":"h3"},{"title":"modules/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#modules","content":" Domain-specific modules (follow the same structure):  Folder / Artifact\tType\tDescriptionapi/\tServices\tAPI consumption for the entity. controllers/\tControllers\tBusiness/control logic of the entity. routes/\tNavigation\tRoutes for the entity. types/\tTypes\tType/interface definitions for the entity. views/\tViews\tPages for the entity (Create, List).  ","version":"Next","tagName":"h3"},{"title":"plugins/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#plugins","content":" Artifact\tType\tDescriptionpinia.ts\tPlugin\tState management configuration (Pinia). router.ts\tPlugin\tRouter configuration. vuetify.ts\tPlugin\tVuetify UI framework configuration. index.ts\tCentral\tCentral export point for plugins.  ","version":"Next","tagName":"h3"},{"title":"routes/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#routes","content":" Artifact\tType\tDescriptionindex.ts\tRoutes\tGlobal route definitions.  ","version":"Next","tagName":"h3"},{"title":"stores/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#stores","content":" Artifact\tType\tDescriptionauth.ts\tGlobal State\tAuthentication state management. ui.ts\tGlobal State\tUI state management (theme, navigation, etc.).  ","version":"Next","tagName":"h3"},{"title":"types/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#types","content":" Artifact\tType\tDescriptionui.ts\tTypes\tGlobal application types.  ","version":"Next","tagName":"h3"},{"title":"utils/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#utils","content":" Artifact\tType\tDescriptionregras.ts\tUtility\tHelper functions and business rules.  ","version":"Next","tagName":"h3"},{"title":"views/​","type":1,"pageTitle":"Artifact Mapper","url":"/leds-tools-public/spark/sparklib_advanced/frontend/artifact_map#views","content":" Artifact\tType\tDescriptionLogin.vue\tPage\tAuthentication page. ","version":"Next","tagName":"h3"},{"title":"Front-end Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/frontend/frontend","content":"","keywords":"","version":"Next"},{"title":"Generators​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/frontend#generators","content":" The generators, in TypeScript, creates the code, the files and the folders of the frontend.  The generators are organized acordingly with what they create.  The generators on the superiors parts create the structure and call the generators in the level below them. This generators will create a specific part of the code and the respective files and/or will create other folders and call their respective generators.  ","version":"Next","tagName":"h2"},{"title":"Generator's Organization​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/frontend#generators-organization","content":" ","version":"Next","tagName":"h2"},{"title":"Main Generator​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/frontend#main-generator","content":" Creates the App.vue and configuration files. Vue's main file.Calls the router (src/router). Creates the public folder.Creates the src folder.  ","version":"Next","tagName":"h3"},{"title":"frontend/public​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/frontend#frontendpublic","content":" Defines the public assets for the project, like the favicon image, but still nothing really substantial.  ","version":"Next","tagName":"h3"},{"title":"frontend/src​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/frontend#frontendsrc","content":" Folder with multiple subfolders. Each subfolder is responsible for part of the frontend components.  Api: Defines and manage same API features, like axios, vite token and admin interceptors. Assets: Defines the main style used in pages (tailwind) and same image files. Components: Defines the main components, like datatables, cards and sidenavs. Layouts: Defines the components disposition on the screen. Modules: Defines the work of mainly generated entitities, proving routes, stores, controllers, API's, views, in order to provides CRUD operations. Plugins: Imports Vuetify to style the components and define the default theme. Routes: Defines the routes for homepage, login, etc. Stores: Makes the user configurations (e.g.: authentication, followers, posts) and manage UI elements, as snackbars. Types: Defines password validation rules. Utils: Defines password validation rules. Views: Defines a simple Login page to aplication. ","version":"Next","tagName":"h3"},{"title":"Motivation","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/componentBasedArchitecture","content":"Before proceeding with the explanation of the specific architectures implemented, we must introduce the component-based architecture. Motivation In the early days of the internet, web applications and websites were developed in a static manner, meaning with little to no dynamically generated pages. The holy trinity—Hypertext Markup Language (HTML), Cascading Style Sheets (CSS), and JavaScript (JS)—was not used with the concern that it should update on its own without the need for server-side preprocessing of the pages. Therefore, languages like Hypertext Preprocessor (PHP) were used in monolithic structures, linking the frontend with the database through preprocessing. As time passed, the internet grew in importance, and many devices, particularly smartphones, needed to access it. Due to differences in screen sizes and compatibility, in order for a person using a mobile device to access a website with quality, it was often necessary to reimplement parts of the business logic in the responsive modules of the system, greatly increasing development costs. Thus, a migration process began from the monolithic structure to the separation of the frontend and backend, where the latter is mostly configured as a REST API. With the formal division between backend and frontend, the creation of responsiveness for a website to work on both computers and mobile devices no longer influences business logic; everything is contained in a single place. There are various ways to develop a frontend, and due to the difficulty of working solely and exclusively with the holy trinity, there was still a need for preprocessing HTML. Additionally, pure HTML, CSS, and JS do not provide built-in, easy-to-use tools for code reuse. Therefore, there was a need for a resource or concept to address all of the aforementioned issues. Components: One of the Possible Solutions Several proposals have been made to meet the demands of frontend development. One of the most successful is the use of components. It’s hard to say which tool implemented this feature first, but one of the most influential frameworks to adopt a component-based structure was React, which is still widely used today. Many other frameworks that came after React, such as Vue, Angular, and Next, also implement components, and all follow a very similar architecture. For this reason, we need to first understand the architecture from a general perspective before diving into specifics. What is a Component? A component is essentially a reusable piece of code that expands into HTML within another section of HTML. This feature is typically implemented through an abstraction of HTML that is preprocessed and then returned as raw HTML. Let’s take React as an example. In React, components are defined as the return value of a function, and that return is typically a string (or a JSX structure) containing HTML tags. Once a component function is defined, it can be imported into another file and used as if it were a native HTML tag within the return of another component. Here’s a code example: File1.jsx const ComponentName = () =&gt; { return ( &lt;&gt; &lt;span&gt;Hello World 1&lt;/span&gt; &lt;span&gt;Hello World 2&lt;/span&gt; &lt;/&gt; ); }; export default ComponentName; File2.jsx import ComponentName from &quot;path/to/component/File1.jsx&quot;; const OtherComponent = () =&gt; { return ( &lt;&gt; &lt;ComponentName /&gt; &lt;/&gt; ); }; Resulting HTML &lt;span&gt;Hello World 1&lt;/span&gt; &lt;span&gt;Hello World 2&lt;/span&gt; This is how HTML is used in React. Now notice — every HTML code in React is used in the form of a component, meaning everything is a component. Despite that, there is an informal division among components. Typically, the term component refers to a piece of code that is reused across multiple parts of the project. However, there are also components that serve a specific, single purpose. These specific components are commonly referred to as pages, templates, or views — depending on the author’s preference. Generalizing the Architecture With the foundational understanding of component-based architecture, all other architectures will generally follow a similar pattern regardless of the framework used. Typically, there is one folder for reusable components and another for pages, both located within a larger folder that contains the main source code files (usually named src in frameworks based on NodeJS). In addition, there is always some form of HTML abstraction and a way to import components into one another. Other functionalities, such as route configuration, API communication, and so on, are more flexible—although there are common implementation patterns and recommendations, they are not strictly defined.","keywords":"","version":"Next"},{"title":"Front-end Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/frontend_architecture","content":"","keywords":"","version":"Next"},{"title":"Generators​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/frontend_architecture#generators","content":" The generators, in TypeScript, creates the code, the files and the folders of the frontend.  The generators are organized acordingly with what they create.  The generators on the superiors parts create the structure and call the generators in the level below them. This generators will create a specific part of the code and the respective files and/or will create other folders and call their respective generators.  ","version":"Next","tagName":"h2"},{"title":"Generator's Organization​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/frontend_architecture#generators-organization","content":" ","version":"Next","tagName":"h2"},{"title":"Main Generator​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/frontend_architecture#main-generator","content":" Creates the App.vue and configuration files. Vue's main file.Calls the router (src/router). Creates the public folder.Creates the src folder.  ","version":"Next","tagName":"h3"},{"title":"frontend/public​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/frontend_architecture#frontendpublic","content":" Defines the public assets for the project, like the favicon image, but still nothing really substantial.  ","version":"Next","tagName":"h3"},{"title":"frontend/src​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/frontend_architecture#frontendsrc","content":" Folder with multiple subfolders. Each subfolder is responsible for part of the frontend components.  Api: Defines and manage same API features, like axios, vite token and admin interceptors. Assets: Defines the main style used in pages (tailwind) and same image files. Components: Defines the main components, like datatables, cards and sidenavs. Layouts: Defines the components disposition on the screen. Modules: Defines the work of mainly generated entitities, proving routes, stores, controllers, API's, views, in order to provides CRUD operations. Plugins: Imports Vuetify to style the components and define the default theme. Routes: Defines the routes for homepage, login, etc. Stores: Makes the user configurations (e.g.: authentication, followers, posts) and manage UI elements, as snackbars. Types: Defines password validation rules. Utils: Defines password validation rules. Views: Defines a simple Login page to aplication. ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/OverView","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/sparklib_advanced/OverView#features","content":" Automatic generation of Vue Modular frontend project structure.Full Tailwind CSS support.Integration with SEONLibImplementation for project abstraction.Folder and file organization based on frontend development best practices.    ","version":"Next","tagName":"h2"},{"title":"Technologies Used​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/sparklib_advanced/OverView#technologies-used","content":" Vue.js (Modular Architecture)Tailwind CSSSEONLibImplementation (as source of Project Abstraction)    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/sparklib_advanced/OverView#prerequisites","content":" Have SEONLibImplementation installed and configured.Development environment configured with Node.js, if you wish to run and test the generated projects.    ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/sparklib_advanced/OverView#installation","content":" # Clone this repository git clone https://github.com/guilhermbc/leds-tools-spark-lib.git # Access the project folder cd leds-tools-spark-lib # Install dependencies, if necessary npm install  ","version":"Next","tagName":"h2"},{"title":"Attention, Legacy Page","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy","content":"","keywords":"","version":"Next"},{"title":"1.1 Vue VS Vuetify VS Vite​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#11-vue-vs-vuetify-vs-vite","content":" The generated frontend relies on the participation of three main frameworks: Vue, Vuetify, and Vite.  Vue is the primary framework, meaning it is the most important in this list. It is responsible for component management, HTML preprocessing, object reactivity control, and more. Other frameworks and libraries can emerge from Vue, each serving a specific purpose.  Vuetify is one of these tools that emerge from Vue. It is essentially a collection of ready-to-use, reusable components, complete with a set of properties and useful features.  Lastly, Vite is an external tool used to optimize the development and build process of the project. With Vite, when editing code, a hot update is performed in real-time, applying only the changes made, which speeds up the development process. Additionally, when building the project, the site is optimized by Vite.    2. The Architecture    The project is divided into three layers: src, public, and cypress.  The public layer contains static files used in development.The cypress layer is responsible for containing the code that generates the basic pages for each entity — currently, it includes pages for listing, viewing, updating, creating, and deleting entities.The src folder contains the actual page files and scripts — the core of the frontend.  2.1 Src Folder    ","version":"Next","tagName":"h2"},{"title":"2.2 Router​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#22-router","content":" The router folder contains the configuration for the vue-router extension, which is responsible for managing the frontend endpoints. Currently, it has a single file that centralizes all the application's routes, but it is possible to break it up into separate files for smaller files and better organization.  ","version":"Next","tagName":"h2"},{"title":"2.3 Views​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#23-views","content":" This layer is responsible for containing the application's page components. Within it, there is a subdivision based on the packages defined in the Spark model. Inside each package, the defined entities have separate folders, each containing the reference files IndexEntity.vue, FormIndex.vue, and DetailsIndex.vue. These pages, together, automatically enable the basic operations for each entity (CRUD). The view layer can also consume the SCSS layer directly.  ","version":"Next","tagName":"h2"},{"title":"2.5 Service plus Composition​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#25-service-plus-composition","content":" The service layer is responsible for managing the HTTP requests from the frontend. With the help of a Factory, a series of EntityRequires files are created, each generating a set of requests defined in the composition/usesApi.ts file — including create, update, remove, list, and getById. In each EntityRequires, the basic endpoint URL for the entity's operations is hardcoded, which is then combined by the factory with the base URL of the API (the backend URL).  ","version":"Next","tagName":"h2"},{"title":"2.6 Components​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#26-components","content":" The components layer is intended to store components that can be reused across multiple pages. Currently, a Breadcrumbs component is generated, which helps the user navigate the site, indicating the navigation path at the top of the screen and providing a sidebar for navigation.    Image 7: Frontend Example. At top screen, the Breadcrumbs component.  ","version":"Next","tagName":"h2"},{"title":"2.7 SCSS and Layouts​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#27-scss-and-layouts","content":" The SCSS folder stores SCSS files (a variant of CSS) for custom styles that are shared across pages when needed. The layouts layer, on the other hand, contains configuration for the layout of certain elements throughout the application. As an example, the sidebar configuration is handled internally within the layouts folder. It can also be used to manage responsive behavior across the application.  ","version":"Next","tagName":"h2"},{"title":"2.8 Utils​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#28-utils","content":" The utils folder contains scripts that are used in various parts of the code but do not belong to a specific context. Simple functions for text manipulation or global configurations reside in the utils folder.  ","version":"Next","tagName":"h2"},{"title":"2.9 Plugins​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#29-plugins","content":" The plugins folder contains the configuration of external plugins used in the application. In this case, only Vite is used, so it is the only one present in this folder. Any new external plugin configurations should be added here.  ","version":"Next","tagName":"h2"},{"title":"2.10 Stores​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#210-stores","content":" The stores layer is responsible for storing configurations locally in the client's browser. For example, authentication cookie settings are handled here.  ","version":"Next","tagName":"h2"},{"title":"2.11 Theme​","type":1,"pageTitle":"Attention, Legacy Page","url":"/leds-tools-public/spark/sparklib_advanced/frontend/generated_arch/vuePlusVuetfy#211-theme","content":" The theme layer contains the application's color configuration. It is loaded by Vue itself and applies color styling across all layers of the application.  3. Suggestions for Improvements:  The view files are very large. In a single file, both interface control and entity manipulation are handled. It is preferable that for each page, a corresponding script be created to handle the entities, and the .vue file should deal only with the interface.  The routes file is very large. It would be better to create a folder for each module, and each entity should have its own routes file to make searching and reading easier.  The pages make little use of request interface definitions from each other. It would be better to have a layer to centralize the Data Transformation Objects from requests into JS objects.  Request handling is being done in a decentralized manner. It would be better to have a layer to configure and manage the requests and entities, while the views focus on displaying this data on the screen and calling these actions when necessary. ","version":"Next","tagName":"h2"},{"title":"Tool vs Library Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/SparkVsSparklib","content":"","keywords":"","version":"Next"},{"title":"Spark Tool (leds-tools-spark)​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#spark-tool-leds-tools-spark","content":" ","version":"Next","tagName":"h2"},{"title":"Purpose​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#purpose","content":" The VS Code extension and CLI interface that provides user interaction and DSL parsing.  ","version":"Next","tagName":"h3"},{"title":"Key Responsibilities​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#key-responsibilities","content":" DSL Parsing: Interprets .Spark files using Langium grammarUser Interface: VS Code extension with syntax highlighting and commandsCLI Interface: Command-line tool for automationIntegration: Connects user input to the processing library  ","version":"Next","tagName":"h3"},{"title":"Core Components​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#core-components","content":" application/ # Domain applications (Project, Team, TimeBox, etc.) language/ # Langium DSL grammar and parser static/ # Monaco Editor UI files cli/ # Command-line interface extension/ # VS Code extension code   ","version":"Next","tagName":"h3"},{"title":"Technologies​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#technologies","content":" Langium: DSL creation and parsingVS Code Extension API: Editor integrationNode.js: CLI and backend processingTypeScript: Type-safe development  ","version":"Next","tagName":"h3"},{"title":"Spark Library (leds-tools-Spark-lib)​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#spark-library-leds-tools-spark-lib","content":" ","version":"Next","tagName":"h2"},{"title":"Purpose​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#purpose-1","content":" The core processing engine that generates documentation, charts, and handles GitHub integration.  ","version":"Next","tagName":"h3"},{"title":"Key Responsibilities​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#key-responsibilities-1","content":" Data Processing: Transforms parsed DSL into actionable data structuresDocumentation Generation: Creates markdown reports and documentationVisualization: Generates SVG charts and dependency diagramsGitHub Integration: Pushes data to GitHub Issues and Projects  ","version":"Next","tagName":"h3"},{"title":"Core Components​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#core-components-1","content":" models/ # Data models (Project, Sprint, Issue, etc.) markdown/ # Documentation generation services chart/ # SVG chart generators (CFD, throughput, dependencies) util/ # Common utilities and helpers service/ # GitHub API integration   ","version":"Next","tagName":"h3"},{"title":"Key Services​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#key-services","content":" MarkdownService: Orchestrates documentation generationGitHubService: Handles GitHub API operationsChartGenerators: Creates visual diagramsDependencyAnalyzer: Analyzes task relationships  ","version":"Next","tagName":"h3"},{"title":"Separation Benefits​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#separation-benefits","content":" ","version":"Next","tagName":"h2"},{"title":"1. Modularity​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#1-modularity","content":" Tool focuses on user interactionLibrary focuses on data processingClear separation of concerns  ","version":"Next","tagName":"h3"},{"title":"2. Reusability​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#2-reusability","content":" Library can be used independentlyMultiple frontends can use the same libraryDifferent deployment scenarios supported  ","version":"Next","tagName":"h3"},{"title":"3. Maintainability​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#3-maintainability","content":" Easier to test individual componentsClear API boundariesIndependent versioning possible  ","version":"Next","tagName":"h3"},{"title":"4. Extensibility​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#4-extensibility","content":" New frontends can be added easilyLibrary features can be extended independentlyPlugin architecture support  ","version":"Next","tagName":"h3"},{"title":"Integration Flow​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#integration-flow","content":"   ","version":"Next","tagName":"h2"},{"title":"Usage Patterns​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#usage-patterns","content":" ","version":"Next","tagName":"h2"},{"title":"Tool-mediated Usage​","type":1,"pageTitle":"Tool vs Library Architecture","url":"/leds-tools-public/spark/SparkVsSparklib#tool-mediated-usage","content":" # Via CLI spark-cli generate path/to/spark/file # Via VS Code Extension # Right-click &gt; Generate All # Right-click &gt; Generate Backend # Right-click &gt; Generate Frontend # Right-click &gt; Project Documentation   This architecture allows Spark to be both user-friendly through the tool interface and powerful through direct library integration. ","version":"Next","tagName":"h3"},{"title":"Test.AI","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/testai_minimundo","content":"","keywords":"","version":"Next"},{"title":"Context​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_minimundo#context","content":" The Test.AI extension for VS Code uses AI to generate automated tests from code. Now, the team needs to create a new functionality that generates test plans, ensuring that it meets its requirements and that the test artifacts produced comply with IEEE standards (829/29119).    ","version":"Next","tagName":"h2"},{"title":"Test Target System​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_minimundo#test-target-system","content":" Tool: Test.AI Extension (VSCode).New: Generation of complete Test Plans (IEEE 829/29119). -Main functions to be validated:Create IEEE Test Plan automatically from code + requirements.Generate mandatory sections of the standard (objective, scope, resources, schedule, risks, acceptance criteria, etc.).Export the plan in Markdown or PDF.Ensure consistency between Test Plans and Test Cases already suggested by Test.AI.    ","version":"Next","tagName":"h2"},{"title":"Actors​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_minimundo#actors","content":" Managers: Gabriel, Ryan, Paulo Vitor.Developers: Dominic, Levi.Test.AI (Extension): generates Test Cases + IEEE Test Plans.    ","version":"Next","tagName":"h2"},{"title":"Objectives of the new functionality​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_minimundo#objectives-of-the-new-functionality","content":" Generate test plans in the IEEE standard    ","version":"Next","tagName":"h2"},{"title":"Rules and Restrictions​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_minimundo#rules-and-restrictions","content":" Test Plans must follow the IEEE structure (without omissions in critical sections).The SmartCart system will be the main benchmark to validate the quality of test plans. ","version":"Next","tagName":"h2"},{"title":"How to Run Test.AI","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/testai_guide","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#prerequisites","content":" Before you begin, make sure you have the following software installed:  Python (including pip package manager)Visual Studio CodeNode.js (recommended)    ","version":"Next","tagName":"h3"},{"title":"STEP 1: Install the Python Library​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#step-1-install-the-python-library","content":" Open a terminal.Run the command:  pip install test-ai-leds   Make sure the Python Scripts directory is added to your PATH environment variable.  🔹 Windows​  Run:  pip show test-ai-leds   You will see a path similar to:  C:\\Users\\user\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python312\\site-packages   Replace site-packages with Scripts, for example:  C:\\Users\\user\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python312\\Scripts   Add this path to your system environment variables.  You can also use virtual environments to avoid global installation.  🔹 Linux​  Create a virtual environment:  python -m venv &lt;nome-da-venv&gt;   Activate the venv:  source &lt;caminho-da-venv&gt;/bin/activate   Install the library:  pip install test-ai-leds   Add the scripts path to .bashrc:  nano ~/.bashrc   Add at the end of the file:  export PATH=$PATH:/&lt;caminho-da-venv&gt;/bin   Then run:  source ~/.bashrc     ","version":"Next","tagName":"h3"},{"title":"STEP 2: Install the Test.AI Extension in VS Code​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#step-2-install-the-testai-extension-in-vs-code","content":" Open Visual Studio Code.Go to the Extensions tab (square icon or shortcut Ctrl + Shift + X).Search for Test.AI.Install the extension.    ","version":"Next","tagName":"h3"},{"title":"STEP 3: Configure the .env File​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#step-3-configure-the-env-file","content":" In the root folder of the repository (leds-tools-testai), create a file called .env with the following content:  LLM_MODEL=gemini/gemini-1.5-flash GEMINI_API_KEY=&lt;Sua Chave&gt; SWAGGER_PATH=&lt;Caminho para o Swagger&gt; DTO_SOURCE=&lt;Caminho para a pasta DTO&gt;   Example:​  LLM_MODEL=gemini/gemini-1.5-flash GEMINI_API_KEY=asduf24385HDSuyad43trfjedsig SWAGGER_PATH=C:/Users/usuario/OneDrive/Documentos/PS2/leds-tools-testai/dtos/swagger.json DTO_SOURCE=C:/Users/usuario/OneDrive/Documentos/PS2/leds-tools-testai/dtos     ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#features","content":" ","version":"Next","tagName":"h2"},{"title":"Feature 1: Generate Gherkin Code Files (Features, BDD)​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#feature-1-generate-gherkin-code-files-features-bdd","content":" Prerequisites​  An .andes file inside the andes folder located in (leds-tools-testai).  How to Run​  In the terminal, inside the repository (leds-tools-testai), run:  python src/application/use_cases/crew_gherkin.py   Enter the name of the .andes file (without the extension).The .feature file will be automatically generated in the features folder with the name resposta.feature.    ","version":"Next","tagName":"h3"},{"title":"Feature 2: Generate Feature Steps (C# with xUnit)​","type":1,"pageTitle":"How to Run Test.AI","url":"/leds-tools-public/test_ai/testai_guide#feature-2-generate-feature-steps-c-with-xunit","content":" Prerequisites​  A .feature file inside the features folder located in (leds-tools-testai).  How to Run​  In the terminal, inside the repository (leds-tools-testai), run:  python src/application/use_cases/crew_xUnit.py   Enter the name of the .feature file (without the extension).The resposta.cs file will be generated inside the resposta folder located in (leds-tools-testai).   ","version":"Next","tagName":"h3"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/testai_project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/test_ai/testai_project_managment#backlog","content":" Backlog atualizado no Github  ID\tTarefa\tTipo\tPrioridade\tObservações01\tDefinir o modelo YAML do plano de testes (padrão IEEE) + exemplos mínimos de entrada\tDocumentação\tAlta\tModelo acordado; exemplos .andes/Swagger prontos 02\tImplementar parser + pipeline com CrewAI → gerar YAML\tDesenvolvimento\tAlta\tGera YAML válido a partir das entradas 03\tValidação da saída (schema/lint e tratamento de erros)\tTestes\tAlta\tReprova inválidos; aprova válidos 04\tIntegração ao Test.AI (acionar geração e salvar artefatos)\tDesenvolvimento\tAlta\tAção/command funcional; arquivos salvos no local definido 05\tTestes (unitários + E2E + verificação simples no CI)\tTestes\tAlta\tSuite verde e checagem do CI passando 06\tDocumentação e demo (como usar/evoluir + roteiro de demonstração)\tDocumentação\tMédia\tGuia “copiar-e-colar” e fluxo de demo disponíveis  ","version":"Next","tagName":"h2"},{"title":"Plano de Comunicação​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/test_ai/testai_project_managment#plano-de-comunicação","content":" Canal no Discord ","version":"Next","tagName":"h2"},{"title":"TodoList - A Complete Pipeline","type":0,"sectionRef":"#","url":"/leds-tools-public/todo_list/","content":"","keywords":"","version":"Next"},{"title":"1. General Description​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#1-general-description","content":" The To-Do List system is an application that allows users to organize their daily tasks. Through it, the user can create, view, update, delete, and manage tasks, as well as organize them by categories, set deadlines, and track their status.  ","version":"Next","tagName":"h2"},{"title":"2. Features​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#2-features","content":" ","version":"Next","tagName":"h2"},{"title":"2.1. User Registration​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#21-user-registration","content":" Allow users to create an account in the system.Required data: Name, Email, Password.  ","version":"Next","tagName":"h3"},{"title":"2.2. User Authentication​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#22-user-authentication","content":" Allow login and logout.Secure authentication with encrypted password.  ","version":"Next","tagName":"h3"},{"title":"2.3. Task Management​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#23-task-management","content":" Create Task: Fields: Title, Description, Due Date, Priority, Status, Category (optional). Edit Task: Allow updating any task information. Delete Task: Allow removing a task from the system. List Tasks: View all registered tasks with filters by: status, due date, priority, and category. Change Status: Possible statuses: Pending, In Progress, Completed, Canceled.  ","version":"Next","tagName":"h3"},{"title":"2.4. Task Organization​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#24-task-organization","content":" Create and manage categories (e.g., Work, Study, Personal).Filter tasks by category.  ","version":"Next","tagName":"h3"},{"title":"2.5. Notifications (Optional)​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#25-notifications-optional","content":" Send reminders for tasks close to the due date (via email or in-system notification).  ","version":"Next","tagName":"h3"},{"title":"3. Functional Requirements​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#3-functional-requirements","content":" ID\tDescriptionRF01\tThe system must allow users to register with name, email, and password. RF02\tThe system must allow user authentication. RF03\tThe system must allow users to create new tasks. RF04\tThe system must allow users to edit existing tasks. RF05\tThe system must allow users to delete tasks. RF06\tThe system must list the user’s tasks. RF07\tThe system must allow changing the status of tasks. RF08\tThe system must allow users to create and manage categories. RF09\tThe system must allow filtering tasks by status, date, and category. RF10\tThe system may send notifications about pending or upcoming tasks.  ","version":"Next","tagName":"h2"},{"title":"4. Non-Functional Requirements​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#4-non-functional-requirements","content":" ID\tDescriptionRNF01\tThe system must have secure authentication with password encryption. RNF02\tIt must be a responsive application, working well on desktop and mobile. RNF03\tThe backend must be developed in [e.g., Node.js, Django, Spring Boot]. RNF04\tThe frontend must be developed in [e.g., Vue.js, React, Angular]. RNF05\tThe system must support at least 100 concurrent users. RNF06\tRequest response time must not exceed 2 seconds in 95% of cases.  ","version":"Next","tagName":"h2"},{"title":"5. Data Model​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#5-data-model","content":" User  id (UUID)name (string)email (string, unique)password (hash)  Category  id (UUID)name (string)user_id (UUID, FK)  Task  id (UUID)title (string)description (string)due_date (date)priority (enum: low, medium, high)status (enum: pending, in progress, completed, canceled)category_id (UUID, FK, optional)user_id (UUID, FK)  ","version":"Next","tagName":"h2"},{"title":"6. Main Flow​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#6-main-flow","content":" The user accesses the system and logs in or registers.  Once logged in, they see their task dashboard.  They can create a new task by filling in title, description, date, and initial status.  They can update the status as progress is made (e.g., pending → in progress → completed).  They can filter tasks by date, status, or category.  They can delete tasks that are no longer needed.  They track their tasks on the dashboard.  ","version":"Next","tagName":"h2"},{"title":"7. Technologies (Example)​","type":1,"pageTitle":"TodoList - A Complete Pipeline","url":"/leds-tools-public/todo_list/#7-technologies-example","content":" Frontend: Vue.js with Tailwind CSSBackend: Django Rest Framework or C#Database: PostgreSQLHosting: Render, Railway, or Vercel ","version":"Next","tagName":"h2"},{"title":"Test.AI","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/testai_overview","content":"","keywords":"","version":"Next"},{"title":"What is Test.AI​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#what-is-testai","content":" Test.AI is a software that uses language models (LLMs) and artificial intelligence agents to efficiently generate automated test files. It operates in two main stages: Gherkin File Generation and Step Generation in C# using xUnit, based on requirement documents in the .andes format, as well as the generation of IEEE-standard test plans.  ","version":"Next","tagName":"h3"},{"title":"Key benefits:​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#key-benefits","content":" Reduces test writing time.Generates consistent and readable test code.Produces IEEE-standard test plans.Integrates with VS Code and CLI for different usage scenarios.  ","version":"Next","tagName":"h3"},{"title":"How to use in Visual Studio Code:​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#how-to-use-in-visual-studio-code","content":" Install the extension from the VS Code extensions tab.Use a .andes file or a Gherkin .feature file.To use the feateures, follow the steps in Getting Started.  ","version":"Next","tagName":"h3"},{"title":"Technologies Employed​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#technologies-employed","content":" PythonCrewAINodejs    ","version":"Next","tagName":"h3"},{"title":"CrewAI + Python​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#crewai--python","content":" ","version":"Next","tagName":"h2"},{"title":"Generating Gherkin Tests with CrewAI​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#generating-gherkin-tests-with-crewai","content":" CrewAI → framework for orchestrating agents (writers, reviewers and managers).Python 3 → main language.Dic/List → static typing..andes (file) → main input with the user case (use case to be transformed into test scenarios).YAML → defines agents, tasks and outputs.  ","version":"Next","tagName":"h2"},{"title":"What is the .andes file and how/where is it used​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#what-is-the-andes-file-and-howwhere-is-it-used","content":" The .andes file is an input document that contains the use case description that will serve as the basis for generating Gherkin tests.  It is read at the script entrypoint (__main__) via:  with open(f&quot;andes/{file}.andes&quot;) as file: andes = file.read()   The content of .andes is passed as a parameter to the crew_gherkin function:  resultado = crew_gherkin(andes, strings)   In other words, .andes → feeds the writer/reviewer agents, which then generate automated test scenarios.  ","version":"Next","tagName":"h3"},{"title":"What is CrewAI and how/where is it used​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#what-is-crewai-and-howwhere-is-it-used","content":" CrewAI is a library for coordinating multiple LLM Agents that interact with each other in a structured execution flow.  In this code, it is the engine for collaborative Gherkin test generation:  Each Agent is loaded from YAML definitions (AgentLoader). Eg: gherkin_writer writes the tests.E.g.: gherkin_reviewer reviews the tests.E.g.: manager_gherkin consolidates the final version. Each Task defines an action to be performed by the agent. Ex.: gherkin_code generates the initial code.E.g.: gherkin_review evaluates and adjusts.E.g.: manager_gherkin_task generates the final artifact (features/resposta.feature). Crew is instantiated and triggers the flow:  crew: Crew = Crew( agents=agents+[manager], tasks=tasks+[final_task], max_rpm=10, output_log_file=&quot;crew_log.txt&quot;, manager_llm=llm_low_temp, process=Process.sequential, verbose=True ) resultado = crew.kickoff()   It coordinates the sequential execution of agents and tasks until the production of the .feature file.  This is an automated pipeline for transforming use cases described in .andes files into Gherkin test scenarios. The code does this via CrewAI, orchestrating a team of agents (writers, reviewers and manager), who collaborate in multiple rounds of writing/revision until generating the final artifact:  Expected output: a .feature file ready to be used in BDD test automation.  ","version":"Next","tagName":"h3"},{"title":"XUnit Test Generation with CrewAI​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#xunit-test-generation-with-crewai","content":" Python 3.x → main programming language.CrewAI → orchestration of agents that write, review, and manage test code.Custom Loaders (src.infrastructure.loaders) AgentLoader → initializes agents.TaskLoader → loads tasks.LLM_Loader → instantiates language models.read_yaml_strings → loads YAML configuration. YAML → defines agents, tasks, and output examples.External Files features/*.feature → main input, defines BDD scenarios.dtos/ → directory containing request/response classes (DTOs).docs/endpoints.txt → contains API endpoints mapped to features.  ","version":"Next","tagName":"h2"},{"title":"What is the .feature File and How/Where it is Used​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#what-is-the-feature-file-and-howwhere-it-is-used","content":" The .feature file is the main input containing the BDD scenario description.  It is read at the script entrypoint (__main__): with open(f&quot;features/{file}.feature&quot;) as file: feature = file.read() Its content is used in three stages: Agent debate (crew_xunit_debate) → agents discuss how to implement the test. Info gatherer (info_gatherer_crew) → automatically locates: DTOs inside the dtos/ folder.Corresponding endpoint in docs/endpoints.txt. Code generation (crew_xunit_generation) → creates, reviews, and refines XUnit code.  The .feature file acts as the seed that drives the entire test generation process.  ","version":"Next","tagName":"h3"},{"title":"What is CrewAI and How/Where it is Used​","type":1,"pageTitle":"Test.AI","url":"/leds-tools-public/test_ai/testai_overview#what-is-crewai-and-howwhere-it-is-used","content":" CrewAI is the core component coordinating collaborative work among LLM agents. In this script, it is used in four main workflows:  crew_xunit_debate Defines a csharp_xunit_writer agent to create the initial test proposal.Creates up to 3 discussion agents that debate different solutions.Uses a result_analysis_manager agent to consolidate the final version.Produces an intermediate output at modalidade_bolsa_crew.cs. info_gatherer_crew Defines specialized agents: API Path Finder → reads endpoints.txt and finds the API route for the feature. File Search Specialist → searches DTOs in the dtos/ directory. Tasks executed: dto_file_find → extracts DTO class content.api_url_find → identifies the corresponding API URL. Outputs are written to: dto_code.txt → DTO code.api_url.txt → API URL. crew_xunit_generation Uses DTOs + API URL to generate XUnit test code.Pipeline: Initial proposal (xunit_code_proposal) → generates C# XUnit test code.Review (xunit_review) → refines the generated code. Logs results in crew_log.txt. manager_crew Consolidates results from three parallel executions of crew_xunit_generation. Uses the result_analysis_manager agent to produce the final consolidated test in:  resposta/VersionarModalidadeStepAI.cs   This code implements an intelligent pipeline for generating automated XUnit tests in C# from .feature specifications.  Expected output: C# test code generated under resposta/*.cs, derived from the .feature file, the actual API endpoint, and corresponding DTOs. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}